<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林伟源的技术博客</title>
  
  
  <link href="https://linweiyuan.github.io/atom.xml" rel="self"/>
  
  <link href="https://linweiyuan.github.io/"/>
  <updated>2022-09-24T09:25:39.000Z</updated>
  <id>https://linweiyuan.github.io/</id>
  
  <author>
    <name>林伟源</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ingress配置pgAdmin需要注意的问题</title>
    <link href="https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2022-09-23T17:32:34.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去</p><p>但是基于 K8s 环境下部署的时候，需要稍微注意一点地方</p><h1 id="K8s-集群准备"><a href="#K8s-集群准备" class="headerlink" title="K8s 集群准备"></a>K8s 集群准备</h1><p>K8s 的搭建方式多种多样，比如 k3d、kubeadm、kind 等，由于多年之前有裸装 Oracle 把系统搞烂的经历，对于一些软件的安装，我这边是比较谨慎的。况且后面接触了容器，能在里面跑就里面跑，什么两倍读写的问题不考虑，所以我使用的是 <code>kind</code> 来搭建集群</p><p>为了服务在容器外能访问，kind 创建 K8s 集群的时候还需要一些额外的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kind.x-k8s.io/v1alpha4</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">apiServerAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">apiServerPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">control-plane</span></span><br><span class="line">    <span class="attr">kubeadmConfigPatches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        kind: InitConfiguration</span></span><br><span class="line"><span class="string">        nodeRegistration:</span></span><br><span class="line"><span class="string">          kubeletExtraArgs:</span></span><br><span class="line"><span class="string">            node-labels: &quot;ingress-ready=true&quot;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">extraPortMappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h1 id="Ingress-Controller-准备"><a href="#Ingress-Controller-准备" class="headerlink" title="Ingress Controller 准备"></a>Ingress Controller 准备</h1><p>K8s 暴露服务的方式也多种多样，比如 NodePort、LoadBalancer、Ingress。由于 kind 的特殊性，整个 K8s 集群都跑在容器中，所以就算 NodePort 也是容器里的端口，所以这次主要讨论 Ingress，使用的是 <code>Nginx</code></p><p>使用 Ingress，首先需要在集群中安装一个 Ingress Controller，然后通过 Ingress 来进行一些配置，当 apply 的时候，Ingress Controller 会自动更新 nginx.conf 并进行 reload</p><p>如果之前配置过 Nginx，其实类比起来是很像的，一个 Ingress Controller 相当于一个 Nginx，一个 Ingress 则好比 Nginx 的配置文件</p><p>当 Ingress Controller 准备好后，会以 NodePort 的方式暴露 80 和 443 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.30.54    &lt;none&gt;        80:30860/TCP，443:31875/TCP   3d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pgAdmin-准备"><a href="#pgAdmin-准备" class="headerlink" title="pgAdmin 准备"></a>pgAdmin 准备</h1><p>为了简单起见，使用 <code>helm</code> 来安装 pgAdmin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pgadmin runix/pgadmin4 --<span class="built_in">set</span> env.email=root@linweiyuan.com --<span class="built_in">set</span> env.password=toor</span><br></pre></td></tr></table></figure><h1 id="Ingress-准备"><a href="#Ingress-准备" class="headerlink" title="Ingress 准备"></a>Ingress 准备</h1><p>配置好 Ingress 规则，因为想做到访问不同的 path 路由到不同的服务，所以这里用 &#x2F;pgAdmin 来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>但是此时访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a> 的时候，会返回 404</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not Found The requested URL was not found on the server. If you entered the URL</span><br><span class="line">manually please check your spelling and try again.</span><br></pre></td></tr></table></figure><h1 id="pgAdmin-访问解决"><a href="#pgAdmin-访问解决" class="headerlink" title="pgAdmin 访问解决"></a>pgAdmin 访问解决</h1><p>查看<a href="https://www.pgadmin.org/docs/pgadmin4/latest/container_deployment.html#http-via-nginx">官方文档</a>，会发现这么一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If you wish to host pgAdmin under a subdirectory rather than on the root of the server, you must specify the location and set the X-Script-Name header which tells the pgAdmin container how to rewrite paths</span><br></pre></td></tr></table></figure><p>就是说 Nginx 的配置里要加 <code>X-Script-Name</code>，但是在 K8s 里要怎么加？</p><p>前面提过，其实无非是修改 Ingress 的配置，此时如果进入 Ingress Controller 的 pod 中查看配置文件，会发现当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ hostname</span><br><span class="line">ingress-nginx-controller-65b4b4df7d-rhd2k</span><br><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   415location = /pgAdmin &#123;</span><br><span class="line">   421<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br></pre></td></tr></table></figure><p>而根据 pgAdmin 官方文档的指引，需要把配置加到 location 下，回头查看 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#configuration-snippet">K8s 官方文档</a>，发现其实是配置 <code>nginx.ingress.kubernetes.io/configuration-snippet</code></p><p>因此配置文件进行修改，完整配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/configuration-snippet:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      proxy_set_header X-Script-Name /pgAdmin;</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>再 apply</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kaf pgadmin-ingress.yaml</span><br><span class="line">ingress.networking.k8s.io/pgadmin-ingress configured</span><br></pre></td></tr></table></figure><p>再查看 nginx.conf，已经生效了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   409proxy_set_header X-Script-Name /pgAdmin;</span><br><span class="line">   417location = /pgAdmin &#123;</span><br><span class="line">   423<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   529proxy_set_header X-Script-Name /pgAdmin;</span><br></pre></td></tr></table></figure><p>此时再访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a></p><p>会自动跳转 <a href="http://localhost/pgAdmin/login?next=/pgAdmin/">http://localhost/pgAdmin/login?next=%2FpgAdmin%2F</a></p><p>用上面 helm 设置的用户名和密码即可登录进去，问题解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去&lt;/p&gt;
&lt;p&gt;但是基于 K8s 环境下部署的时候，需要稍微注意一点地方&lt;/p&gt;
&lt;h1 id=&quot;K8s-集群准备&quot;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="pgAdmin" scheme="https://linweiyuan.github.io/tags/pgAdmin/"/>
    
    <category term="Ingress" scheme="https://linweiyuan.github.io/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用服务</title>
    <link href="https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html</id>
    <published>2022-07-26T18:42:48.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理了下常用的 <code>Docker</code> 服务： <a href="https://github.com/linweiyuan/docker-services">https://github.com/linweiyuan/docker-services</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理了下常用的 &lt;code&gt;Docker&lt;/code&gt; 服务： &lt;a href=&quot;https://github.com/linweiyuan/docker-services&quot;&gt;https://github.com/linweiyuan/docker-services&lt;/a&gt;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 使用国内镜像源时遇到的坑</title>
    <link href="https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
    <id>https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</id>
    <published>2022-07-25T02:50:47.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>详见：<a href="https://github.com/ustclug/discussions/issues/396">https://github.com/ustclug/discussions/issues/396</a></p><p>“故从 2020 年 4 月起，从科大校外对 Docker Hub 镜像缓存的访问会被 302 重定向至其他国内 Docker Hub 镜像源”</p><p>可以看到是重定向到阿里云</p><p><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a> -&gt; <a href="https://ustc-edu-cn.mirror.aliyuncs.com/">https://ustc-edu-cn.mirror.aliyuncs.com</a></p><p>但是校外访问这个仓库已经是旧的了</p><p>替代品</p><ul><li>直连</li><li>阿里云（广州或杭州，或自己账号）：<a href="https://registry.cn-guangzhou.aliyuncs.com/">https://registry.cn-guangzhou.aliyuncs.com</a></li><li>网易（容易连着连着自动断开）：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详见：&lt;a href=&quot;https://github.com/ustclug/discussions/issues/396&quot;&gt;https://github.com/ustclug/discussions/issues/396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;“故从 2020 年 4 </summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK18的UTF-8</title>
    <link href="https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html"/>
    <id>https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html</id>
    <published>2022-03-24T07:07:34.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JEP-400-UTF-8-by-Default"><a href="#JEP-400-UTF-8-by-Default" class="headerlink" title="JEP 400: UTF-8 by Default"></a>JEP 400: UTF-8 by Default</h1><p>JDK18 里有一项改进叫：<a href="https://openjdk.org/jeps/400">JEP 400: UTF-8 by Default</a></p><p>其实是将默认字符集改为 UTF-8，只是 Charset.defaultCharset() 返回 UTF-8，在这之前的 JDK 版本中，返回的字符集根据操作系统的不同会不一样，有可能会导致乱码，可以看到这个方法的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br><span class="line"></span><br><span class="line">The <span class="keyword">default</span> charset is UTF-<span class="number">8</span>, unless changed in an implementation specific manner.</span><br></pre></td></tr></table></figure><p>之前的版本只有这一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br></pre></td></tr></table></figure><p>所以并不是改了 String 的实现</p><h1 id="JEP-254-Compact-Strings"><a href="#JEP-254-Compact-Strings" class="headerlink" title="JEP 254: Compact Strings"></a>JEP 254: Compact Strings</h1><p>Java 中的 String 默认采用 UTF-16 字符集，这其实是历史的包袱，为了要支持新版本的 Unicode，又要保证向后兼容，因为谁也想不到计算机的发展是如此迅猛，当时是足够用了</p><p>如今用了 UTF-16，可以存大部分辅助字符（Emoji 等）了，但是对于西方国家，日常的简单字母，有点浪费</p><p>因此 JDK9 进行了改动，将底层 char[] 改为 byte[]，并且在原有基础上加入了 Latin-1（ISO-8859-1）字符集，详细可以看这个 JEP：<a href="https://openjdk.org/jeps/254">JEP 254: Compact Strings</a></p><p>String(UTF-16 + Latin-1)，其中内部多了个字段 coder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br></pre></td></tr></table></figure><p>当无法用 Latin-1 表示的时候，才使用 UTF-16，减少了内存的浪费</p><p>所以 JEP 400 和 String 本身的实现关系不大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JEP-400-UTF-8-by-Default&quot;&gt;&lt;a href=&quot;#JEP-400-UTF-8-by-Default&quot; class=&quot;headerlink&quot; title=&quot;JEP 400: UTF-8 by Default&quot;&gt;&lt;/a&gt;JEP 400: UTF-</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="JDK18" scheme="https://linweiyuan.github.io/tags/JDK18/"/>
    
  </entry>
  
  <entry>
    <title>分布式Session的几种实现方式</title>
    <link href="https://linweiyuan.github.io/2020/09/15/%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html"/>
    <id>https://linweiyuan.github.io/2020/09/15/%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html</id>
    <published>2020-09-15T09:01:37.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<p>包含但不限于：</p><h1 id="粘性-Session"><a href="#粘性-Session" class="headerlink" title="粘性 Session"></a>粘性 Session</h1><p>每次请求都会转发到指定的机器，比如 Nginx 的 ip_hash，将用户和机器绑定起来，造成单机的效果，实现起来较为简单，只需加一些额外的配置</p><p>但是这种方式有一定的局限性，一旦当前服务器发生故障，用户会被转发到其他服务器上，Session 信息就会丢失</p><h1 id="Session-复制"><a href="#Session-复制" class="headerlink" title="Session 复制"></a>Session 复制</h1><p>这种方式需要服务器的支持，每当 Session 发生改变，该节点就会自动将 Session 内容广播给其他节点</p><p>因此对服务器的带宽有一定的占用，如果数据量过多，可能会对请求的响应造成一定的影响</p><h1 id="Session-共享"><a href="#Session-共享" class="headerlink" title="Session 共享"></a>Session 共享</h1><p>可以将 Session 信息存入 Redis</p><p>缺点就是每次引入第三方中间件，都要考虑可靠性问题，挂了怎么办</p><h1 id="Session-持久化到数据库"><a href="#Session-持久化到数据库" class="headerlink" title="Session 持久化到数据库"></a>Session 持久化到数据库</h1><p>持久化 Session 有一个好处就是当服务器发生故障的时候，Session 不会丢失</p><p>缺点就是给数据库造成了额外的负担</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>将数据放在 Cookie 里，实现起来也比较简单</p><p>只是数据放在浏览器里是不安全的，不能放敏感数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;包含但不限于：&lt;/p&gt;
&lt;h1 id=&quot;粘性-Session&quot;&gt;&lt;a href=&quot;#粘性-Session&quot; class=&quot;headerlink&quot; title=&quot;粘性 Session&quot;&gt;&lt;/a&gt;粘性 Session&lt;/h1&gt;&lt;p&gt;每次请求都会转发到指定的机器，比如 Nginx</summary>
      
    
    
    
    <category term="架构设计" scheme="https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis" scheme="https://linweiyuan.github.io/tags/Redis/"/>
    
    <category term="Session" scheme="https://linweiyuan.github.io/tags/Session/"/>
    
    <category term="Cookie" scheme="https://linweiyuan.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>如何生成分布式系统全局唯一ID</title>
    <link href="https://linweiyuan.github.io/2020/09/10/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID.html"/>
    <id>https://linweiyuan.github.io/2020/09/10/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID.html</id>
    <published>2020-09-10T08:43:10.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<p>方案有很多，包括但不限于以下几种</p><h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>利用 INCR 命令，INCR 命令是一个原子操作，Redis 又是单线程</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>利用 ObjectId，ObjectId 由 4 部分组成（时间戳，机器标识符，进程 ID，自增计数器）</p><p>只能说重复的概率可以忽略不计</p><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>可以利用 ZooKeeper 的顺序节点来完成，当创建顺序节点时，ZooKeeper 会根据创建的时间顺序，在节点名称后面添加 10 位的顺序编号</p><h1 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h1><p>推特的雪花算法，趋势递增，一般不会重复，除非修改系统时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方案有很多，包括但不限于以下几种&lt;/p&gt;
&lt;h1 id=&quot;UUID&quot;&gt;&lt;a href=&quot;#UUID&quot; class=&quot;headerlink&quot; title=&quot;UUID&quot;&gt;&lt;/a&gt;UUID&lt;/h1&gt;&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;he</summary>
      
    
    
    
    <category term="架构设计" scheme="https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis" scheme="https://linweiyuan.github.io/tags/Redis/"/>
    
    <category term="UUID" scheme="https://linweiyuan.github.io/tags/UUID/"/>
    
    <category term="MongoDB" scheme="https://linweiyuan.github.io/tags/MongoDB/"/>
    
    <category term="ZooKeeper" scheme="https://linweiyuan.github.io/tags/ZooKeeper/"/>
    
    <category term="Snowflake" scheme="https://linweiyuan.github.io/tags/Snowflake/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin动态代理</title>
    <link href="https://linweiyuan.github.io/2020/08/27/Kotlin%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"/>
    <id>https://linweiyuan.github.io/2020/08/27/Kotlin%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</id>
    <published>2020-08-27T19:59:12.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method!!.invoke(obj, *(args ?: emptyArray()))</span><br></pre></td></tr></table></figure><hr><p>相比之下<code>Java</code>的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(obj, args);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Kotlin" scheme="https://linweiyuan.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8新特性</title>
    <link href="https://linweiyuan.github.io/2020/07/14/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
    <id>https://linweiyuan.github.io/2020/07/14/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7.html</id>
    <published>2020-07-14T08:35:31.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这个时间点还来谈 JDK 1.8 的新特性是有点不合时宜的，毕竟 JDK 都出到几了，但是在大环境下（国内，国外不知道），只要 Spring 不出致命漏洞，JDK 1.8 在 2026 年之前还是主流，毕竟谁没事去重构老系统，新系统开发可遇不可求</p><h1 id="函数式编程-x2F-lambda"><a href="#函数式编程-x2F-lambda" class="headerlink" title="函数式编程 &#x2F; lambda"></a>函数式编程 &#x2F; lambda</h1><h2 id="比如获取最小值的实现方式"><a href="#比如获取最小值的实现方式" class="headerlink" title="比如获取最小值的实现方式"></a>比如获取最小值的实现方式</h2><p>之前，啰嗦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(IntStream.of(a).min().getAsInt());</span><br></pre></td></tr></table></figure><h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br></pre></td></tr></table></figure><p>只能有一个待实现的方法（可有很多默认方法）</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>可链式调用</p><table><thead><tr><th>接口</th><th>输入参数</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>断言</td></tr><tr><td>Consumer<T></td><td>T</td><td>无</td><td>消费一个数据</td></tr><tr><td>Function&lt;T, R&gt;</td><td>T</td><td>R</td><td>输入 T 输出 R 的函数</td></tr><tr><td>Supplier<T></td><td>无</td><td>T</td><td>提供一个数据</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>一元函数（输入输出类型相同）</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>(T, U)</td><td>R</td><td>2 个输入相同的函数</td></tr><tr><td>BinaryOperator<T></td><td>(T, T)</td><td>T</td><td>二元函数（输入输出类型相同）</td></tr></tbody></table><p>基本数据类型的演变</p><p>Predicate<Integer> -&gt; IntPredicate，其他的类似</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>非静态方法，使用对象的实例来引用</p><p>使用类名来访问，因为 JDK 自带了第一个参数在方法里，内容是 this（不显示），所以用 BiFunction</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br></pre></td></tr></table></figure><p>构造函数的方法引用</p><p>Java 是值传递</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><h2 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h2><p>JDK 1.8 之前，匿名函数内部访问外部的变量，外部变量要为 final；lambda 则可不写 final（但变量不能改，否则编译出错）</p><h1 id="Stream-流编程"><a href="#Stream-流编程" class="headerlink" title="Stream 流编程"></a>Stream 流编程</h1><ul><li>外部迭代：fori</li><li>内部迭代：并行流</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这个时间点还来谈 JDK 1.8 的新特性是有点不合时宜的，毕竟 JDK 都出到几了，但是在大环境下（国内，国外不知道），只要 Spring 不出致命漏洞，JDK 1.8 在 2026 年之前还是主流，毕竟谁没事去重构老系统，新系统开发可遇不可求&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>缓存和数据库一致性的保障方案</title>
    <link href="https://linweiyuan.github.io/2020/06/07/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E9%9A%9C%E6%96%B9%E6%A1%88.html"/>
    <id>https://linweiyuan.github.io/2020/06/07/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E9%9A%9C%E6%96%B9%E6%A1%88.html</id>
    <published>2020-06-07T08:02:32.000Z</published>
    <updated>2022-09-24T09:25:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>业界流行的有下面几种，不能说孰优孰劣，只能具体问题具体分析，软件开发没有银弹</p><h1 id="同步删除"><a href="#同步删除" class="headerlink" title="同步删除"></a>同步删除</h1><p>同步删除说明了是同步，所以流程的处理就是一步一步来，先更新数据库的数据，再对缓存进行删除</p><p>没有问题吗？</p><p>假如并发场景下，有两条线程，一条线程查询了数据库，还没来得及写缓存，但是另一条线程更新了这条数据库记录，并完成了写缓存操作，这时原来的线程再回过头来写缓存，就会有脏数据</p><p>又假如本来是应该在 API 里进行数据的更新的，但是有人直接连上数据库进行 update，这样数据库的数据是被删掉了，但是在 API 的层面并不知道，所以缓存中的数据还是旧的</p><p>再加入同步删除过程中发生异常了，也会存在脏数据问题</p><h1 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h1><p>延时双删顾名思义就是延时 + 双删，先删一次缓存，接着更新数据库，休眠毫秒级的时间，再删一次缓存</p><p>没有问题吗？</p><p>到底要休眠多久，这个要看具体的业务需求</p><p>数据库主从架构下，写主库，数据同步到从库需要一定的时间，不能保证强一致性，万一双删后数据还没同步完成，此时有请求过来了，就缓存了旧数据</p><h1 id="监听-binlog"><a href="#监听-binlog" class="headerlink" title="监听 binlog"></a>监听 binlog</h1><p>监听 binlog 其实解决了同步删除的场景下，通过 API 外操作数据库的问题</p><p>比如用 Canal，只要你更新数据库，无论你是正常请求 API 更新，还是直接连数据库，都能监听到，然后就能对缓存进行删除</p><p>没有问题吗？</p><p>和消息队列一样，解耦了，吞吐量提高了，但是严重依赖第三方中间件，Canal 挂了怎么办</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业界流行的有下面几种，不能说孰优孰劣，只能具体问题具体分析，软件开发没有银弹&lt;/p&gt;
&lt;h1 id=&quot;同步删除&quot;&gt;&lt;a href=&quot;#同步删除&quot; class=&quot;headerlink&quot; title=&quot;同步删除&quot;&gt;&lt;/a&gt;同步删除&lt;/h1&gt;&lt;p&gt;同步删除说明了是同步，所以流程的</summary>
      
    
    
    
    <category term="架构设计" scheme="https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis" scheme="https://linweiyuan.github.io/tags/Redis/"/>
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot事务什么时候会失效</title>
    <link href="https://linweiyuan.github.io/2020/05/01/Spring-Boot%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88.html"/>
    <id>https://linweiyuan.github.io/2020/05/01/Spring-Boot%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88.html</id>
    <published>2020-05-01T03:58:34.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 的事务管理是依赖 AOP 的，AOP 又与反射和动态代理关系密不可分，所以，有下面几种方式，包括 Spring 本身，数据库本身的配置是否合理</p><ul><li>bean 对象没有被 Spring 容器管理</li><li>方法的访问修饰符不是 public</li><li>自身调用</li><li>数据源没有配置事务管理器</li><li>数据库不支持事务</li><li>异常被捕获</li><li>异常类型错误或者配置错误</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring Boot 的事务管理是依赖 AOP 的，AOP 又与反射和动态代理关系密不可分，所以，有下面几种方式，包括 Spring 本身，数据库本身的配置是否合理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bean 对象没有被 Spring 容器管理&lt;/li&gt;
&lt;li&gt;方法的访问修饰符</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Spring Boot" scheme="https://linweiyuan.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>微信开发的坑</title>
    <link href="https://linweiyuan.github.io/2020/04/27/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%9A%84%E5%9D%91.html"/>
    <id>https://linweiyuan.github.io/2020/04/27/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%9A%84%E5%9D%91.html</id>
    <published>2020-04-27T08:12:13.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参数<br>部分<code>xml</code>, 部分<code>json</code></p></li><li><p>接口校验<br>首次校验接口<code>SHA-1</code>参数值字典序, 其他接口<code>MD5</code>参数值<code>key</code>, <code>value</code>字典序</p></li><li><p>微信支付<br><a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2">企业付款</a>: 参数<code>mch_appid</code>, <code>mchid</code>, 旁边<code>签名算法</code>链接的示例整个<code>appid</code>, <code>mch_id</code><br><a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=23_1&index=2">支付验收指引</a> 就是<code>sandbox</code></p><ul><li>参数又变成<code>mch_id</code></li><li>不能输入随意金额</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数&lt;br&gt;部分&lt;code&gt;xml&lt;/code&gt;, 部分&lt;code&gt;json&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口校验&lt;br&gt;首次校验接口&lt;code&gt;SHA-1&lt;/code&gt;参数值字典序, 其他接口&lt;code&gt;MD5&lt;/code&gt;参数值&lt;c</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Kotlin" scheme="https://linweiyuan.github.io/tags/Kotlin/"/>
    
    <category term="WeChatPay" scheme="https://linweiyuan.github.io/tags/WeChatPay/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot跨域配置</title>
    <link href="https://linweiyuan.github.io/2020/03/13/Spring-Boot%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE.html"/>
    <id>https://linweiyuan.github.io/2020/03/13/Spring-Boot%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE.html</id>
    <published>2020-03-13T07:54:05.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<p>前后端跨域问题解决方案多种多样，前端可以通过中间件解决，因为跨域发生在浏览器的 XHR 中，普通的 HTTP 请求是正常的</p><p>另一种是在网关那里进行配置，比如利用 Nginx 做反向代理或者负载均衡，可以在 Nginx 上面配置对应的响应头</p><p>如果要在 API 的层面进行配置，Spring Boot 提供了多种方式，下面是其中一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前后端跨域问题解决方案多种多样，前端可以通过中间件解决，因为跨域发生在浏览器的 XHR 中，普通的 HTTP 请求是正常的&lt;/p&gt;
&lt;p&gt;另一种是在网关那里进行配置，比如利用 Nginx 做反向代理或者负载均衡，可以在 Nginx 上面配置对应的响应头&lt;/p&gt;
&lt;p&gt;如果要</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Spring Boot" scheme="https://linweiyuan.github.io/tags/Spring-Boot/"/>
    
    <category term="CORS" scheme="https://linweiyuan.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Docker相关知识点</title>
    <link href="https://linweiyuan.github.io/2020/02/12/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2020/02/12/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2020-02-12T06:44:54.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器和虚拟机的比较"><a href="#容器和虚拟机的比较" class="headerlink" title="容器和虚拟机的比较"></a>容器和虚拟机的比较</h1><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>性能</td><td>接近原生</td><td>较弱</td></tr><tr><td>内存代价</td><td>很小</td><td>较多</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>运行密度</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td>隔离性</td><td>完全隔离</td><td>完全隔离</td></tr><tr><td>迁移性</td><td>优秀</td><td>一般</td></tr></tbody></table><p>镜像自身是只读的，容器从镜像启动的时候，会在镜像的最上层创建一个可写层</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>dockerfile 一般格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">ENV</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">ADD（自动解压）</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">（不自动解压）</span></span><br><span class="line"><span class="keyword">EXPOSE</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">ENTRYPOINT</span></span><br></pre></td></tr></table></figure><p>.dockerignore 忽略 build 的内容</p><h1 id="基础镜像-alpine"><a href="#基础镜像-alpine" class="headerlink" title="基础镜像 alpine"></a>基础镜像 alpine</h1><p>apk –update add –no-cache <package></p><p>这样可以大幅度减少构建出来的 docker 镜像的大小</p><h1 id="神秘镜像-scratch"><a href="#神秘镜像-scratch" class="headerlink" title="神秘镜像 scratch"></a>神秘镜像 scratch</h1><p>其实这个镜像你去拉是会报错的，更多的是一种类似约定的东西，告诉 Docker，这个就是一个空的东西</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>docker 本质上是一个 C&#x2F;S 架构</p><p>docker 服务端 <code>unix://var/run/docker.socket</code></p><p>如果要以端口的方式暴露，则需要修改执行命令，设置地址和端口，比如 <code>docker daemon -H 0.0.0.0:1234</code></p><p>客户端如果要连接不同的服务端，也需要额外指定，比如 <code>docker -H tcp://127.0.0.1:1234 version</code></p><p>命令 <code>ip addr show docker0</code> 能看到 docker 网卡的相关信息</p><p>docker registry 可以配置 hooks 通知（pull or push）</p><p>docker 第三方安全检测工具：</p><ul><li>docker -&gt; docker bench</li><li>CoreOS -&gt; clair</li></ul><p>容器里的网络 eth0 &lt;-&gt; docker0 网桥上的 vethXXX（veth pair，当数据包发送到一个接口时另外一个接口也可以接收到相同的数据包）</p><p>docker 的 link 主要是添加一个所连接容器的主机名到容器内的&#x2F;etc&#x2F;hosts 文件中</p><p>查看 docker 网络信息 <code>docker network ls</code></p><p>docker 网络分三种：null、host、bridge</p><h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><p>简单: RESTful 接口<br>安全: 基于 HTTPS<br>快速: 支持每秒 1000 个写操作<br>可靠: 基于 Raft 算法</p><p>节点个数推荐为奇数个，最少为 3 个</p><p>越多节点能提供更多的冗余性，但会带来写数据性能的下降</p><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><p>docker swarm 也支持调度，亲和性这些 k8s 的概念</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>Pod 为什么不能通过 IP 访问？</p><p>因为 Pod 随时可能会发生故障，重启后可能会被调度到其他节点上，IP 地址就会改变</p><p>通过 Service 来访问，Service 被创建后，会自动分配一个 Cluster IP，基于 kube-proxy 实现</p><p>kube-proxy 维护节点上的网络规则，作用是使发往 Service 的流量（ClusterIP + 端口）负载均衡到正确的后端 Pod</p><p>Label 主要是用来分类资源，比如 name&#x3D;nginx，release&#x3D;alpha|beta，有长度限制</p><p>Annotation 则主要是给对象增加更丰富的描述信息，可以是任意的，数据量可以很大，可以包含结构化或非结构化数据</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>类似于租户的概念，同一个命名空间的资源不允许重名，但不同命名空间下则允许</p><p>default: 资源未指定命名空间的情况下，默认属于该命名空间</p><p>kube-system：由 Kubernetes 自身创建的资源属于该命名空间下</p><p>hyperkube：提供所有的 k8s 组件支持</p><p>etcd：提供数据库存储</p><p>pause：一个轻量级的基础设施容器，用于为每个 Pod 提前创建命名空间，其他什么也不做</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod 的创建流程</p><ul><li>kubectl 命令发起一个创建 Pod 的请求去到 kube-apiserver</li><li>kube-apiserver 完成基本的验证和授权操作，把 Pod 的相关信息写入 etcd</li><li>kube-scheduler 定时请求 kube-apiserver，确定 Pod 要调度的位置</li><li>kube-apiserver 写 etcd</li><li>kube-apiserver 将信息发给 kubelet 完成 Pod 的创建</li><li>kube-controller-manager 定时请求 kube-apiserver，看 Pod 是否挂掉</li></ul><h2 id="各个组件及其作用"><a href="#各个组件及其作用" class="headerlink" title="各个组件及其作用"></a>各个组件及其作用</h2><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>etcd</td><td>记录所有节点和资源的状态</td></tr><tr><td>kube-apiserver</td><td>接收来自客户端和其他组件的请求，更新 etcd 中的数据</td></tr><tr><td>kube-scheduler</td><td>负责具体的资源调度工作</td></tr><tr><td>kube-controller-manager</td><td>提供控制器服务，监视集群的状态，一但不满足状态则采取操作，让状态恢复正常</td></tr><tr><td>kubelet</td><td>负责干活</td></tr><tr><td>kube-proxy</td><td>网络转发（默认轮询）</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;容器和虚拟机的比较&quot;&gt;&lt;a href=&quot;#容器和虚拟机的比较&quot; class=&quot;headerlink&quot; title=&quot;容器和虚拟机的比较&quot;&gt;&lt;/a&gt;容器和虚拟机的比较&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;容器&lt;/th&gt;
</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>某站程序和文件上传漏洞</title>
    <link href="https://linweiyuan.github.io/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://linweiyuan.github.io/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.html</id>
    <published>2020-01-25T06:44:43.000Z</published>
    <updated>2022-09-24T09:25:39.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用程序漏洞成功以-admin-身份登录后台-数据泄露"><a href="#利用程序漏洞成功以-admin-身份登录后台-数据泄露" class="headerlink" title="利用程序漏洞成功以 admin 身份登录后台, 数据泄露"></a>利用程序漏洞成功以 admin 身份登录后台, 数据泄露</h3><p><img src="/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/admin.png"></p><h3 id="任意文件类型上传-jspx-小-shell"><a href="#任意文件类型上传-jspx-小-shell" class="headerlink" title="任意文件类型上传, jspx 小 shell"></a>任意文件类型上传, jspx 小 shell</h3><p><img src="/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/jspx.png"></p><h3 id="Windows-操作系统"><a href="#Windows-操作系统" class="headerlink" title="Windows 操作系统"></a>Windows 操作系统</h3><p><img src="/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/windows.png"></p><h3 id="数据库配置泄露"><a href="#数据库配置泄露" class="headerlink" title="数据库配置泄露"></a>数据库配置泄露</h3><p><img src="/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/db.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用程序漏洞成功以-admin-身份登录后台-数据泄露&quot;&gt;&lt;a href=&quot;#利用程序漏洞成功以-admin-身份登录后台-数据泄露&quot; class=&quot;headerlink&quot; title=&quot;利用程序漏洞成功以 admin 身份登录后台, 数据泄露&quot;&gt;&lt;/a&gt;利用程序</summary>
      
    
    
    
    <category term="网络安全" scheme="https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Windows" scheme="https://linweiyuan.github.io/tags/Windows/"/>
    
    <category term="Vulnerability" scheme="https://linweiyuan.github.io/tags/Vulnerability/"/>
    
    <category term="JSPX" scheme="https://linweiyuan.github.io/tags/JSPX/"/>
    
  </entry>
  
  <entry>
    <title>Anko放弃维护</title>
    <link href="https://linweiyuan.github.io/2019/12/02/Anko%E6%94%BE%E5%BC%83%E7%BB%B4%E6%8A%A4.html"/>
    <id>https://linweiyuan.github.io/2019/12/02/Anko%E6%94%BE%E5%BC%83%E7%BB%B4%E6%8A%A4.html</id>
    <published>2019-12-02T13:13:54.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>用<code>Anko</code>写过一个<code>Android</code>应用 -&gt; <a href="https://github.com/linweiyuan/MHP">怪物猎人金手指 for Android</a>, 最喜欢的就是<code>doAsync</code>和<code>uiThread</code>, 今天升级下依赖, 发现提示<code>Anko is deprecated</code>, 并且给出了一个说明 -&gt; <a href="https://github.com/Kotlin/anko/blob/master/GOODBYE.md">Discontinuing Anko</a></p><p>截止目前<code>15.4k</code>的<code>Star</code>, 这个项目确实很好, 真是令人惋惜</p><p>希望<code>Ktor</code>能持续发展</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用&lt;code&gt;Anko&lt;/code&gt;写过一个&lt;code&gt;Android&lt;/code&gt;应用 -&amp;gt; &lt;a href=&quot;https://github.com/linweiyuan/MHP&quot;&gt;怪物猎人金手指 for Android&lt;/a&gt;, 最喜欢的就是&lt;code&gt;doAsy</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Kotlin" scheme="https://linweiyuan.github.io/tags/Kotlin/"/>
    
    <category term="Anko" scheme="https://linweiyuan.github.io/tags/Anko/"/>
    
  </entry>
  
  <entry>
    <title>某站XSS漏洞</title>
    <link href="https://linweiyuan.github.io/2019/11/11/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://linweiyuan.github.io/2019/11/11/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-11T07:28:35.000Z</published>
    <updated>2022-09-24T09:25:39.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插入任意-JS-脚本"><a href="#插入任意-JS-脚本" class="headerlink" title="插入任意 JS 脚本"></a>插入任意 JS 脚本</h3><p><img src="/2019/11/11/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E/image.png"></p><h3 id="JS-脚本加载"><a href="#JS-脚本加载" class="headerlink" title="JS 脚本加载"></a>JS 脚本加载</h3><p><img src="/2019/11/11/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E/js.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;插入任意-JS-脚本&quot;&gt;&lt;a href=&quot;#插入任意-JS-脚本&quot; class=&quot;headerlink&quot; title=&quot;插入任意 JS 脚本&quot;&gt;&lt;/a&gt;插入任意 JS 脚本&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/11/11/%E6%9F%90%E7%AB%</summary>
      
    
    
    
    <category term="网络安全" scheme="https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Vulnerability" scheme="https://linweiyuan.github.io/tags/Vulnerability/"/>
    
    <category term="XSS" scheme="https://linweiyuan.github.io/tags/XSS/"/>
    
    <category term="JSPX" scheme="https://linweiyuan.github.io/tags/JSPX/"/>
    
  </entry>
  
  <entry>
    <title>PyPI加速</title>
    <link href="https://linweiyuan.github.io/2019/10/06/PyPI%E5%8A%A0%E9%80%9F.html"/>
    <id>https://linweiyuan.github.io/2019/10/06/PyPI%E5%8A%A0%E9%80%9F.html</id>
    <published>2019-10-06T01:47:06.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://linweiyuan.github.io/tags/Python/"/>
    
    <category term="pip" scheme="https://linweiyuan.github.io/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>Java单例设计模式</title>
    <link href="https://linweiyuan.github.io/2019/09/24/Java%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://linweiyuan.github.io/2019/09/24/Java%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</id>
    <published>2019-09-24T02:21:34.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<p>Java 实现单例设计模式的部分例子，并不是全部</p><h1 id="普通饿汉式"><a href="#普通饿汉式" class="headerlink" title="普通饿汉式"></a>普通饿汉式</h1><p>何为饿汉，就是很饿了，要马上能吃到东西（实例先初始化好，要用时就直接拿来用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式就能实现单例了吗？测试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Singleton.getInstance());</span><br><span class="line">    System.out.println(Singleton.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出相同的地址，确实能实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@6bf2d08e</span><br><span class="line">singleton.Singleton@6bf2d08e</span><br></pre></td></tr></table></figure><p>从上面输出可以看到是实现了的，但是有潜在的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.getInstance());</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt;[] declaredConstructors = Singleton.class.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会得到两个不同的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@6bf2d08e</span><br><span class="line">singleton.Singleton@1b701da1</span><br></pre></td></tr></table></figure><p>如何解决？</p><p>要实现单例，核心有两点：</p><ul><li>私有化构造方法，不能让别人 new</li><li>提供获取实例的方法</li></ul><p>上面的代码就是把原来 private 的构造方法设为 public，然后 new 了下，那知道了这一点，就可以在构造方法那里对应地进行处理</p><p>我都饿汉了，实例早就有了，你还来 new，抛个异常给你</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来测试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@6bf2d08e</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.reflect.InvocationTargetException</span><br></pre></td></tr></table></figure><p>再已经有一个实例的情况下，再通过反射来 new，就会得到一个异常</p><p>但是，没有其他的问题了吗？再来测试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.getInstance());</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray()));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到了流的操作，单例类需要实现 <code>Serializable</code> 接口</p><p>结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@5eb5c224</span><br><span class="line">singleton.Singleton@5ae9a829</span><br></pre></td></tr></table></figure><p>又得到了两个不同的实例</p><p>如何解决？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@5eb5c224</span><br><span class="line">singleton.Singleton@5eb5c224</span><br></pre></td></tr></table></figure><p>解决了，但是为什么 readResolve() 能解决序列化导致两个对象的问题，这个就要稍微看点 JDK 源码（JDK 1.8）</p><p>首先从测试代码的 readObject() 入手（删掉不重点关注或者说看不懂的代码，看源码真的要深入每一行吗？你要这么说，那最核心的都是 native 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class: java.io.ObjectInputStream</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">(Class&lt;?&gt; type)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(type, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(Class&lt;?&gt; type, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">        <span class="keyword">if</span> (type == String.class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(<span class="string">&quot;Cannot cast an object to java.lang.String&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 检查是否有 readResolve 方法</span></span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果有 readResolve 方法，则返回这个方法返回的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class: java.io.ObjectStreamClass</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasReadResolveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">return</span> (readResolveMethod != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                readResolveMethod = getInheritableMethod(</span><br><span class="line">                    cl, <span class="string">&quot;readResolve&quot;</span>, <span class="literal">null</span>, Object.class);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面就是为什么 readResolve() 能防止反序列化出来不同的对象</p><p>但是这样，就能实现单例了吗？再来测试下别的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.getInstance());</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(unsafe.allocateInstance(Singleton.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleton.Singleton@2a139a55</span><br><span class="line">singleton.Singleton@6d06d69c</span><br></pre></td></tr></table></figure><p>这样又能得到两个对象了，因为是比较底层的 Unsafe 类，所以预防不了</p><p>那么有没有其他方法，有，就是枚举饿汉</p><h1 id="枚举类饿汉式"><a href="#枚举类饿汉式" class="headerlink" title="枚举类饿汉式"></a>枚举类饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试反射破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.INSTANCE);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了一个异常 java.lang.NoSuchMethodException，通过 javap 编译出来的 class 文件，可以看到类的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">singleton</span>.Singleton <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;singleton.Singleton&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> singleton.Singleton INSTANCE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> singleton.Singleton[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> singleton.Singleton <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面确实没有无参构造方法，再看继承的 java.lang.Enum 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Enum</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protected 能被继承，所以枚举类里是有带参的构造方法的，如果调用带参的构造方法，会发生什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.INSTANCE);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="keyword">enum</span> <span class="title class_">objects</span></span><br></pre></td></tr></table></figure><p>可以调用，但是报错了，看回反射的源码，可以看到里面做了一个判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class: java.lang.reflect.Constructor</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object ... initargs)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">            IllegalArgumentException, InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以枚举饿汉，是在 JDK 的层面进行了防反射</p><p>再试试反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">    oos.writeObject(Singleton.INSTANCE);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray()));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE</span><br><span class="line">INSTANCE</span><br></pre></td></tr></table></figure><p>得到的是相同的对象，要了解原因，需要从序列化看起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(Singleton.INSTANCE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class: java.io.ObjectOutputStream</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeEnum</span><span class="params">(Enum&lt;?&gt; en,</span></span><br><span class="line"><span class="params">                        ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                        <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 其实序列化就是存枚举类对象的 name</span></span><br><span class="line">    writeString(en.name(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看反序列化，大部分代码和上面普通类的反序列化相同，这里重点列出不同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class: java.io.ObjectInputStream</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(Class&lt;?&gt; type, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">        <span class="keyword">if</span> (type == String.class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(<span class="string">&quot;Cannot cast an enum to java.lang.String&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="type">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    Enum&lt;?&gt; result = <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 核心是这行</span></span><br><span class="line">    Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br><span class="line">    result = en;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; T <span class="title function_">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span><br><span class="line"><span class="params">                                            String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接根据 name 拿回枚举类实例，对应上面存的 name，拿到的就是同一个</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以枚举饿汉也是在 JDK 的层面进行了防反序列化</p><p>那么 Unsafe 又怎么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(Singleton.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(unsafe.allocateInstance(Singleton.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>返回了一个 null，因为这个是 native 方法，具体实现的代码看不懂，这里只放出 Java 这边的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class: sun.misc.Unsafe</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Allocate an instance but do not run any constructor.</span></span><br><span class="line"><span class="comment">    Initializes the class if it has not yet been. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException;</span><br></pre></td></tr></table></figure><p>所以也可以说，枚举饿汉也能防 Unsafe</p><h1 id="普通懒汉式"><a href="#普通懒汉式" class="headerlink" title="普通懒汉式"></a>普通懒汉式</h1><p>懒汉就是没有这么饿，但是很懒，因为懒，所以我不提前给你准备好东西，你催我的时候我再来准备，下面的代码都能实现单例，结果就不放了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法有个问题，因为 INSTANCE 其实是一个共享变量，共享变量在多线程的环境下就会有资源竞争的问题，所以可能两个线程都会判断 INSTANCE 是 null，所以创建了两个对象</p><p>既然这样，那无脑 synchronized 就完了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以是可以，但是锁的粒度太大了，并发量很大的情况下性能会有影响（大部分场景下这些都是空话套话），所以要将锁细化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，只有 INSTANCE 是 null 的时候才会加锁，性能就会大大提升</p><p>但是也会有一个问题，理想情况下是请求一个接着一个来，第一个来了，null，初始化，后面的直接 return，但是在多线程环境下，也会存在两个线程都判断是 null，所以都进去了 if 代码块，虽然只有一个线程能进入 synchronized 代码块，但是一个线程 new 了，就释放锁了，第二个线程还是会 new，这样就会有两个实例</p><p>如何解决？在 synchronized 块里再判断一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然有多个线程判断 INSTANCE 是 null，从而进入 if 代码块，但是只能有一个线程能进入 synchronized 块进行 new 对象，虽然 new 完了别的线程还能进入，但进入后再判断，就不会再 new 了</p><p>看似解决了，但是这种方式在 JVM 层面有一个问题</p><p>new 对象的时候一般会包括但不限于以下几个步骤：</p><ul><li>分配内存空间</li><li>变量初始化</li><li>返回内存地址（赋值）</li></ul><p>但是 JVM 会进行一些优化，江湖人称指令重排序，就是可能会先赋值了再初始化变量，这样以来在多线程的环境下就会得到一个未初始化的对象，那用起来会就有奇怪的问题，为了禁止这个负优化（单例场景下是负优化），需要用 volatile 关键字</p><p>volatile 通过增加内存屏障的方式，禁止指令重排序，除此之外，还可以手动增加内存屏障，通过 Unsafe 类的一些 fence 相关的方法（这个不常用，除非是很底层的代码），volatile 还保证可见性，详细的东西可能单独谈比较合适</p><p>其他注意的点和饿汉式相同</p><h1 id="内部类懒汉式"><a href="#内部类懒汉式" class="headerlink" title="内部类懒汉式"></a>内部类懒汉式</h1><p>内部类是类加载的时候就初始化，类加载是线程安全的，其他注意的点也和上面的类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后总结：大家都说用枚举类单例好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 实现单例设计模式的部分例子，并不是全部&lt;/p&gt;
&lt;h1 id=&quot;普通饿汉式&quot;&gt;&lt;a href=&quot;#普通饿汉式&quot; class=&quot;headerlink&quot; title=&quot;普通饿汉式&quot;&gt;&lt;/a&gt;普通饿汉式&lt;/h1&gt;&lt;p&gt;何为饿汉，就是很饿了，要马上能吃到东西（实例先初始化</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox压缩虚拟硬盘</title>
    <link href="https://linweiyuan.github.io/2019/08/06/VirtualBox%E5%8E%8B%E7%BC%A9%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98.html"/>
    <id>https://linweiyuan.github.io/2019/08/06/VirtualBox%E5%8E%8B%E7%BC%A9%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98.html</id>
    <published>2019-08-06T14:16:22.000Z</published>
    <updated>2022-09-24T09:25:39.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/empty bs=1M</span><br><span class="line">sudo rm -f /empty</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>下载 -&gt; <a href="http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx">Sysinternals Suite</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdelete –z C:</span><br></pre></td></tr></table></figure><p>关机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vboxmanage modifyhd xxx.vdi --compact</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="虚拟机" scheme="https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="VirtualBox" scheme="https://linweiyuan.github.io/tags/VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>Android License</title>
    <link href="https://linweiyuan.github.io/2019/07/26/Android-License.html"/>
    <id>https://linweiyuan.github.io/2019/07/26/Android-License.html</id>
    <published>2019-07-26T14:39:22.000Z</published>
    <updated>2022-09-24T09:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android 开发中提示<code>License for package xxx not accepted.</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">yes</span> | sdkmanager --licenses</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android 开发中提示&lt;code&gt;License for package xxx not accepted.&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Android" scheme="https://linweiyuan.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
