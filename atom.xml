<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林伟源的技术博客</title>
  
  
  <link href="https://linweiyuan.github.io/atom.xml" rel="self"/>
  
  <link href="https://linweiyuan.github.io/"/>
  <updated>2022-09-27T02:07:30.578Z</updated>
  <id>https://linweiyuan.github.io/</id>
  
  <author>
    <name>林伟源</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ingress配置pgAdmin需要注意的问题</title>
    <link href="https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2022-09-23T17:32:34.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去</p><p>但是基于 K8s 环境下部署的时候，需要稍微注意一点地方</p><h1 id="K8s-集群准备"><a href="#K8s-集群准备" class="headerlink" title="K8s 集群准备"></a>K8s 集群准备</h1><p>K8s 的搭建方式多种多样，比如 k3d、kubeadm、kind 等，由于多年之前有裸装 Oracle 把系统搞烂的经历，对于一些软件的安装，我这边是比较谨慎的。况且后面接触了容器，能在里面跑就里面跑，什么两倍读写的问题不考虑，所以我使用的是 <code>kind</code> 来搭建集群</p><p>为了服务在容器外能访问，kind 创建 K8s 集群的时候还需要一些额外的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kind.x-k8s.io/v1alpha4</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">apiServerAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">apiServerPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">control-plane</span></span><br><span class="line">    <span class="attr">kubeadmConfigPatches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        kind: InitConfiguration</span></span><br><span class="line"><span class="string">        nodeRegistration:</span></span><br><span class="line"><span class="string">          kubeletExtraArgs:</span></span><br><span class="line"><span class="string">            node-labels: &quot;ingress-ready=true&quot;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">extraPortMappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h1 id="Ingress-Controller-准备"><a href="#Ingress-Controller-准备" class="headerlink" title="Ingress Controller 准备"></a>Ingress Controller 准备</h1><p>K8s 暴露服务的方式也多种多样，比如 NodePort、LoadBalancer、Ingress。由于 kind 的特殊性，整个 K8s 集群都跑在容器中，所以就算 NodePort 也是容器里的端口，所以这次主要讨论 Ingress，使用的是 <code>Nginx</code></p><p>使用 Ingress，首先需要在集群中安装一个 Ingress Controller，然后通过 Ingress 来进行一些配置，当 apply 的时候，Ingress Controller 会自动更新 nginx.conf 并进行 reload</p><p>如果之前配置过 Nginx，其实类比起来是很像的，一个 Ingress Controller 相当于一个 Nginx，一个 Ingress 则好比 Nginx 的配置文件</p><p>当 Ingress Controller 准备好后，会以 NodePort 的方式暴露 80 和 443 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.30.54    &lt;none&gt;        80:30860/TCP，443:31875/TCP   3d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pgAdmin-准备"><a href="#pgAdmin-准备" class="headerlink" title="pgAdmin 准备"></a>pgAdmin 准备</h1><p>为了简单起见，使用 <code>helm</code> 来安装 pgAdmin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pgadmin runix/pgadmin4 --<span class="built_in">set</span> env.email=root@linweiyuan.com --<span class="built_in">set</span> env.password=toor</span><br></pre></td></tr></table></figure><h1 id="Ingress-准备"><a href="#Ingress-准备" class="headerlink" title="Ingress 准备"></a>Ingress 准备</h1><p>配置好 Ingress 规则，因为想做到访问不同的 path 路由到不同的服务，所以这里用 &#x2F;pgAdmin 来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>但是此时访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a> 的时候，会返回 404</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not Found The requested URL was not found on the server. If you entered the URL</span><br><span class="line">manually please check your spelling and try again.</span><br></pre></td></tr></table></figure><h1 id="pgAdmin-访问解决"><a href="#pgAdmin-访问解决" class="headerlink" title="pgAdmin 访问解决"></a>pgAdmin 访问解决</h1><p>查看<a href="https://www.pgadmin.org/docs/pgadmin4/latest/container_deployment.html#http-via-nginx">官方文档</a>，会发现这么一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If you wish to host pgAdmin under a subdirectory rather than on the root of the server, you must specify the location and set the X-Script-Name header which tells the pgAdmin container how to rewrite paths</span><br></pre></td></tr></table></figure><p>就是说 Nginx 的配置里要加 <code>X-Script-Name</code>，但是在 K8s 里要怎么加？</p><p>前面提过，其实无非是修改 Ingress 的配置，此时如果进入 Ingress Controller 的 pod 中查看配置文件，会发现当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ hostname</span><br><span class="line">ingress-nginx-controller-65b4b4df7d-rhd2k</span><br><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   415location = /pgAdmin &#123;</span><br><span class="line">   421<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br></pre></td></tr></table></figure><p>而根据 pgAdmin 官方文档的指引，需要把配置加到 location 下，回头查看 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#configuration-snippet">K8s 官方文档</a>，发现其实是配置 <code>nginx.ingress.kubernetes.io/configuration-snippet</code></p><p>因此配置文件进行修改，完整配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/configuration-snippet:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      proxy_set_header X-Script-Name /pgAdmin;</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>再 apply</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kaf pgadmin-ingress.yaml</span><br><span class="line">ingress.networking.k8s.io/pgadmin-ingress configured</span><br></pre></td></tr></table></figure><p>再查看 nginx.conf，已经生效了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   409proxy_set_header X-Script-Name /pgAdmin;</span><br><span class="line">   417location = /pgAdmin &#123;</span><br><span class="line">   423<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   529proxy_set_header X-Script-Name /pgAdmin;</span><br></pre></td></tr></table></figure><p>此时再访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a></p><p>会自动跳转 <a href="http://localhost/pgAdmin/login?next=/pgAdmin/">http://localhost/pgAdmin/login?next=%2FpgAdmin%2F</a></p><p>用上面 helm 设置的用户名和密码即可登录进去，问题解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去&lt;/p&gt;
&lt;p&gt;但是基于 K8s 环境下部署的时候，需要稍微注意一点地方&lt;/p&gt;
&lt;h1 id=&quot;K8s-集群准备&quot;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="pgAdmin" scheme="https://linweiyuan.github.io/tags/pgAdmin/"/>
    
    <category term="Ingress" scheme="https://linweiyuan.github.io/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>利用 Github Actions 实现代码提交自动部署更新 Kubernetes</title>
    <link href="https://linweiyuan.github.io/2022/09/13/%E5%88%A9%E7%94%A8GithubActions%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9B%B4%E6%96%B0Kubernetes.html"/>
    <id>https://linweiyuan.github.io/2022/09/13/%E5%88%A9%E7%94%A8GithubActions%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9B%B4%E6%96%B0Kubernetes.html</id>
    <published>2022-09-13T04:31:35.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub: <a href="https://github.com/linweiyuan/github-actions-tests">https://github.com/linweiyuan/github-actions-tests</a></p><p>可以换掉大部分 Jenkins + webhooks 的场景</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=515899777&bvid=BV1Ag411e7DG&cid=842773470&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/linweiyuan/github-actions-tests&quot;&gt;https://github.com/linweiyuan/github-actions-tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以换掉大部</summary>
      
    
    
    
    <category term="Github Actions" scheme="https://linweiyuan.github.io/categories/Github-Actions/"/>
    
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="Golang" scheme="https://linweiyuan.github.io/tags/Golang/"/>
    
    <category term="Github Actions" scheme="https://linweiyuan.github.io/tags/Github-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现 i3bar 显示歌词</title>
    <link href="https://linweiyuan.github.io/2022/09/06/Go%E5%AE%9E%E7%8E%B0i3bar%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D.html"/>
    <id>https://linweiyuan.github.io/2022/09/06/Go%E5%AE%9E%E7%8E%B0i3bar%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D.html</id>
    <published>2022-09-06T04:31:35.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-Go-实现的-i3bar-歌词显示程序"><a href="#基于-Go-实现的-i3bar-歌词显示程序" class="headerlink" title="基于 Go 实现的 i3bar 歌词显示程序"></a>基于 Go 实现的 i3bar 歌词显示程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/linweiyuan/goi3barlyric.git</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar &#123;</span><br><span class="line">    status_command goi3barlyric</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制较多，实验性质</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=473404363&bvid=BV1PT411M7H5&cid=842777138&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-Go-实现的-i3bar-歌词显示程序&quot;&gt;&lt;a href=&quot;#基于-Go-实现的-i3bar-歌词显示程序&quot; class=&quot;headerlink&quot; title=&quot;基于 Go 实现的 i3bar 歌词显示程序&quot;&gt;&lt;/a&gt;基于 Go 实现的 i3bar 歌词显示</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Golang" scheme="https://linweiyuan.github.io/tags/Golang/"/>
    
    <category term="i3" scheme="https://linweiyuan.github.io/tags/i3/"/>
    
    <category term="i3bar" scheme="https://linweiyuan.github.io/tags/i3bar/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用服务</title>
    <link href="https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html</id>
    <published>2022-07-26T18:42:48.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>整理了下常用的 <code>Docker</code> 服务： <a href="https://github.com/linweiyuan/docker-services">https://github.com/linweiyuan/docker-services</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理了下常用的 &lt;code&gt;Docker&lt;/code&gt; 服务： &lt;a href=&quot;https://github.com/linweiyuan/docker-services&quot;&gt;https://github.com/linweiyuan/docker-services&lt;/a&gt;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 使用国内镜像源时遇到的坑</title>
    <link href="https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
    <id>https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</id>
    <published>2022-07-25T02:50:47.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>详见：<a href="https://github.com/ustclug/discussions/issues/396">https://github.com/ustclug/discussions/issues/396</a></p><p>“故从 2020 年 4 月起，从科大校外对 Docker Hub 镜像缓存的访问会被 302 重定向至其他国内 Docker Hub 镜像源”</p><p>可以看到是重定向到阿里云</p><p><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a> -&gt; <a href="https://ustc-edu-cn.mirror.aliyuncs.com/">https://ustc-edu-cn.mirror.aliyuncs.com</a></p><p>但是校外访问这个仓库已经是旧的了</p><p>替代品</p><ul><li>直连</li><li>阿里云（广州或杭州，或自己账号）：<a href="https://registry.cn-guangzhou.aliyuncs.com/">https://registry.cn-guangzhou.aliyuncs.com</a></li><li>网易（容易连着连着自动断开）：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详见：&lt;a href=&quot;https://github.com/ustclug/discussions/issues/396&quot;&gt;https://github.com/ustclug/discussions/issues/396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;“故从 2020 年 4 </summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>30分钟从0到1搭建一个最基础的Rancher</title>
    <link href="https://linweiyuan.github.io/2022/06/04/30%E5%88%86%E9%92%9F%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84Rancher.html"/>
    <id>https://linweiyuan.github.io/2022/06/04/30%E5%88%86%E9%92%9F%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84Rancher.html</id>
    <published>2022-06-04T04:31:35.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>宿主机 Arch Linux，cgroup v2, 安装会报错，解决方案 -&gt; systemd.unified_cgroup_hierarchy&#x3D;0</p><p>简单起见，基于虚拟机 CentOS 7.9，一主两从<br>rancher 管理机：192.168.31.240<br>k8s 一主节点：192.168.31.250<br>k8s 两从节点：192.168.31.251, 192.168.31.252</p><p>docker 私有仓库： distribution&#x2F;registry</p><p>内网 dns：dnsmasq</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=560999944&bvid=BV1Fe4y1B7Bf&cid=842560164&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;宿主机 Arch Linux，cgroup v2, 安装会报错，解决方案 -&amp;gt; systemd.unified_cgroup_hierarchy&amp;#x3D;0&lt;/p&gt;
&lt;p&gt;简单起见，基于虚拟机 CentOS 7.9，一主两从&lt;br&gt;rancher 管理机：192.1</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Arch Linux" scheme="https://linweiyuan.github.io/tags/Arch-Linux/"/>
    
    <category term="Rancher" scheme="https://linweiyuan.github.io/tags/Rancher/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="CentOS" scheme="https://linweiyuan.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>分布式相关理论</title>
    <link href="https://linweiyuan.github.io/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"/>
    <id>https://linweiyuan.github.io/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html</id>
    <published>2022-05-22T09:42:15.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><ul><li>C：Consistency（一致性）<br>访问分布式系统的任何一个节点，得到的数据都是一样的（需要进行数据同步）</li><li>A：Availability（可用性）<br>访问分布式系统中的任何一个健康节点，必须能得到响应，而不是超时或拒绝（需要确保网络畅通）</li><li>P：Partition tolerance（分区容错性）<ul><li>分区：分布式系统中部分节点由于发生网络故障或其他原因导致和其他节点失去连接，形成独立分区</li><li>容错：出现独立分区时，整个系统也要持续对外提供服务</li></ul></li></ul><p>在分布式系统中，网络是一个不确定的因素，但是发生网络故障的时候，服务还要持续对外提供服务，所以分区容错性不可避免</p><p>假如网络不佳，导致有节点故障掉线，此时接收到新的数据变更时：</p><ul><li>如果要保证可用性，就不能等待网络恢复，那节点之间就会出现数据不一致的情况，因为数据同步需要时间</li><li>如果要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，在这个数据同步的过程中，服务暂时不可用</li></ul><p>也就是说，在 P 一定出现的情况下，A 和 C 之间只能实现一个，要么 AP，要么 CP</p><h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>BASE 是对 CAP 的一种扩展</p><ul><li>Basically Available（基本可用）：当分布式系统出现故障时，允许丢失部分可用性，保证核心业务可用</li><li>Soft State（软状态）：在一定的时间内，允许出现数据不一致的状态</li><li>Eventually Consistent（最终一致性）：当软状态结束后，确保数据最终是一致的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;C：Consistency（一致性）&lt;br&gt;访问分布式系统的任何一个节点，得到的数据都是一样的（需要进行数据同步）&lt;/l</summary>
      
    
    
    
    <category term="架构设计" scheme="https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="CAP" scheme="https://linweiyuan.github.io/tags/CAP/"/>
    
    <category term="BASE" scheme="https://linweiyuan.github.io/tags/BASE/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发核心编程卷1读书笔记</title>
    <link href="https://linweiyuan.github.io/2022/05/01/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%8D%B71%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>https://linweiyuan.github.io/2022/05/01/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%8D%B71%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
    <published>2022-05-01T04:13:20.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><ul><li>Channel</li><li>Reactor</li><li>Handler</li><li>Pipeline（双向链表）</li><li>EventLoopGroup</li><li>parentGroup: 负责新连接的监听和接收</li><li>childGroup：负责 IO 事件的轮询和分发<br>如果不分开 parent 和 child,则会带来一个风险：新连接的接收被更加耗时的数据传输或业务处理所阻塞</li><li>ChannelOption</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>API 使用起来相对简单，降低了开发门槛</li><li>对多种主流协议都有很好的支持（编解码功能）</li><li>支持自定义配置，通过 ChannelHandler 可以灵活地扩展通信框架</li><li>其他业界主流的 NIO 框架相比，Netty 的综合性能最优（谁出书都会说自己的好）</li><li>成熟稳定，Netty 修复了在 JDK NIO 中所有已发现的 bug（我也不知道有什么 bug）</li><li>有活跃的社区，版本迭代周期短，bug 修复及时</li></ul><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>核心优势就是解决了分布式环境的数据一致性问题，每时每刻访问 ZooKeeper 的树结构时，返回的数据都是一致的，不会引起脏读、幻读、不可重复读</p><h1 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h1><ul><li>脏读：一个事务中访问到了另一个事务未提交的数据</li><li>幻读：当两个完全相同的查询执行时，两次返回的结果集不一样，原因另一个事务新增或删除了第一个事务的结果集中的数据</li><li>不可重复读：在一个事务内根据同一个条件对数据进行多次查询，返回的结果不一致，原因是其他事务对数据进行了修改</li></ul><p>不可重复读和幻读的区别：</p><p>不可重复读关心的是记录的更新操作，对同样的记录，再次读取数据发生变化</p><p>幻读关注的是记录的增删操作，条数发生了变化</p><h1 id="高并发环境下的接入层"><a href="#高并发环境下的接入层" class="headerlink" title="高并发环境下的接入层"></a>高并发环境下的接入层</h1><p>网关不外乎完成以下工作：</p><ul><li>鉴权</li><li>限流</li><li>反向代理</li><li>负载均衡</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>将内存划分为两部分，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态</p><p>IO 读写：</p><p>上层应用通过操作系统的 read 系统调用，把数据从内核缓冲区复制到应用程序的进程缓冲区，通过操作系统的 write 系统调用，把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区</p><p>那么为什么要设置缓冲区呢？</p><p>是为了减少设备之间的频繁物理交换，因为外部物理设备与内存和 CPU 相比，有着非常大的差距</p><h1 id="四种主要的-IO-模型"><a href="#四种主要的-IO-模型" class="headerlink" title="四种主要的 IO 模型"></a>四种主要的 IO 模型</h1><p>阻塞 IO 指的是，需要内核 IO 操作彻底完成后，才返回用户空间执行用户程序的操作指令，非阻塞则无需等待</p><p>同步指的是用户空间（进程或线程）是主动发起 IO 请求的一方，系统内核是被动接收方；异步 IO 则反过来</p><ul><li>同步阻塞 IO：用户空间主动发起，需要等待内核 IO 操作彻底完成后，才返回到用户空间的 IO 操作<ul><li>优点：应用程序开发非常简单，在阻塞等待数据的过程中，用户线程挂起，基本不会占用 CPU 资源</li><li>缺点：一般情况下会为每个连接配备一个独立的线程，高并发场景下，需要大量线程，内存和线程切换开销会非常大</li></ul></li><li>同步非阻塞 IO：用户空间发起，不需要等待内核 IO 操作彻底完成，就可以立即返回用户空间去执行后续的指令（这个也叫 NIO，但是和 Java 里面的 NIO 有区别，Java 里的 NIO 指的是 NewIO，用的是 IO 多路复用模型），特点是需要不断进行轮询<ul><li>优点：线程不会阻塞，实时性较好</li><li>缺点：需要不断轮询，占用 CPU 资源，效率低下</li></ul></li><li>IO 多路复用：在 Linux 系统中，IO 多路复用的系统调用为 select&#x2F;epoll，通过该系统调用，一个用户进程（或线程）可以监视多个文件描述符，一旦某个文件描述符就绪（一般是指内核缓冲区可读&#x2F;可写），内核就能够将文件描述符的就绪状态返回给用户进程（或线程），用户空间就可以根据文件描述符的就绪状态进行对应的 IO 系统调用（Reactor）<ul><li>优点：一个选择器查询线程可以同时处理成千上万的网络连接，不必创建大量的线程</li><li>缺点：select&#x2F;epoll 系统调用是阻塞的，属于同步 IO</li></ul></li><li>异步 IO：指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者；用户线程通过系统调用向内核注册某个 IO 操作，内核在这个 IO 操作完成后通知用户程序，用户程序执行后续的业务操作（回调）<ul><li>优点：非阻塞</li><li>缺点：应用程序仅需要进行事件的注册和接收，其余的工作都留给了操作系统，也就是需要底层内核提供支持</li></ul></li></ul><h1 id="连接极限值"><a href="#连接极限值" class="headerlink" title="连接极限值"></a>连接极限值</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 1000000（默认 1024）</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -SHn（S 软性极限值，超过警告；H 硬性极限值，超过报错）</span><br></pre></td></tr></table></figure><p>如何彻底解除限制？</p><p>编辑文件 <code>/etc/security/limits.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 1000000</span><br><span class="line">hard nofile 1000000</span><br></pre></td></tr></table></figure><h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="基本组件-1"><a href="#基本组件-1" class="headerlink" title="基本组件"></a>基本组件</h2><ul><li>Channel</li><li>Buffer</li><li>Selector</li></ul><h2 id="OIO-和-NIO-的区别"><a href="#OIO-和-NIO-的区别" class="headerlink" title="OIO 和 NIO 的区别"></a>OIO 和 NIO 的区别</h2><ul><li>OIO（Old IO） 面向流，NIO（New IO）面向缓存区</li><li>OIO 是阻塞的，NIO 非阻塞</li><li>OIO 没有 Selector 概念，NIO 有</li></ul><h1 id="NIO-Buffer"><a href="#NIO-Buffer" class="headerlink" title="NIO Buffer"></a>NIO Buffer</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p>allocate(int capacity)： 默认是写模式，从数组下标 0 开始，长度限制是 capacity</p></li><li><p>put(int i)：写 i 进数组里，如果超过长度，则抛出 BufferOverflowException（可使用 remaining() 来判断剩余可写长度；如果是读模式，则抛出 ReadOnlyBufferException（可使用 isReadOnly() 来判断是否可写）</p></li><li><p>filp()：读写模式转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p></li><li><p>rewind()：倒带</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flip() 和 rewind() 的区别就是 limit 参数</p></li><li><p>mark() 和 reset(): mark() 标记当前位置，当调用 reset() 的时候，回到标记的位置</p></li><li><p>clear()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用 clear() 或者 compact() 可以将读模式改为写模式</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>allocate() -&gt; put() -&gt; flip() -&gt; get() -&gt; clear() &#x2F; compoact() -&gt; put()</p><h2 id="申请内存的两种方式"><a href="#申请内存的两种方式" class="headerlink" title="申请内存的两种方式"></a>申请内存的两种方式</h2><p>申请堆内存，读写效率较低，受到 GC 影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer.allocate() -&gt; java.nio.HeapByteBuffer</span><br></pre></td></tr></table></figure><p>申请直接内存，读写效率高（少一次拷贝），不会受到 GC 影响，分配内存的时候效率低，使用不当可能造成内存泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer.allocateDirect() -&gt; java.nio.DirectByteBuffer</span><br></pre></td></tr></table></figure><h1 id="NIO-Channels"><a href="#NIO-Channels" class="headerlink" title="NIO Channels"></a>NIO Channels</h1><h2 id="常用-Channel"><a href="#常用-Channel" class="headerlink" title="常用 Channel"></a>常用 Channel</h2><ul><li>FileChannel</li><li>(FileInputStream() &#x2F; FileOutputStream()).geChannel(), ByteBuffer.flip(), channel.force(true), channel.close()</li><li>transferTo(position, length, target)：零拷贝, 每次 2G 上限</li><li>ServerSocketChannel</li><li>SocketChannel</li><li>socketChannel.configureBlocking(true &#x2F; false)，默认是 blocking, 因为有个属性设置 nonBlocking 为 false</li><li>DatagramChannael</li></ul><h1 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h1><p>选择器的使命是处理 IO 的多路复用，完成通道的注册，监听，事件查询</p><p>选择器和通道的关系是监控和被监控的关系</p><h2 id="IO-事件类型"><a href="#IO-事件类型" class="headerlink" title="IO 事件类型"></a>IO 事件类型</h2><ul><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li></ul><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>如何知道一个 Channel 是否能被监测？</p><p>看这个 Channel 是否直接或间接继承 SelectableChannel，比如 FileChannel 就不是，而 SocketChannel 就是</p><p>注册到 Selector 的 Channel 必须是处于非阻塞模式下，因为 FileChannel 只有阻塞模式，不能切换到非阻塞模式，所以 FileChannel 不能和选择器一起使用</p><p>Selector.select() 本身是阻塞的，所以放在 while true 里不用担心 CPU 空转</p><h1 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h1><p>Reactor 模式由 Reactor 线程，Handlers 处理器两大角色组成</p><ul><li>Reactor 线程：负责响应 IO 事件，并且分发到 Handlers 处理器</li><li>Handlers 处理器：非阻塞地执行业务逻辑处理</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>channel -&gt; selector -&gt; reactor -&gt; handler</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>响应速度快，虽然同一 Reactor 线程本身是同步的，但是不会被单个连接的 IO 操作所阻塞</li><li>避免了多线程同步和线程之前频繁切换的开销</li><li>通过增加 Reactor 线程的个数，可以进行灵活扩展，充分利用 CPU 资源</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>每次引入新东西肯定是增加了原系统的复杂性</li><li>需要操作系统底层支持 IO 多路复用系统调用才可以</li></ul><h1 id="为什么在海量连接的情况下，线程池的方式不好使"><a href="#为什么在海量连接的情况下，线程池的方式不好使" class="headerlink" title="为什么在海量连接的情况下，线程池的方式不好使"></a>为什么在海量连接的情况下，线程池的方式不好使</h1><ul><li>线程的创建和销毁成本很高</li><li>线程本身占用较大内存，Java 线程栈内存分配 <code>512K - 1M</code></li><li>线程切换的成本很高，因为需要保存上下文，如果线程切换的时间比线程本身执行所需要的时间还多，就是负优化</li></ul><h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><ul><li>数据结构大小：原则上，越小，效率越高</li><li>结构复杂度：越复杂，效率越低</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Netty&quot;&gt;&lt;a href=&quot;#Netty&quot; class=&quot;headerlink&quot; title=&quot;Netty&quot;&gt;&lt;/a&gt;Netty&lt;/h1&gt;&lt;h2 id=&quot;基本组件&quot;&gt;&lt;a href=&quot;#基本组件&quot; class=&quot;headerlink&quot; title=&quot;基本组件&quot;</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://linweiyuan.github.io/tags/Netty/"/>
    
    <category term="NIO" scheme="https://linweiyuan.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux简易安装脚本（i3, kde, deepin）</title>
    <link href="https://linweiyuan.github.io/2022/04/08/Arch-Linux%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88i3-kde-deepin%EF%BC%89.html"/>
    <id>https://linweiyuan.github.io/2022/04/08/Arch-Linux%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88i3-kde-deepin%EF%BC%89.html</id>
    <published>2022-04-08T04:19:56.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>脚本：<a href="https://github.com/linweiyuan/archlinux-install-script">https://github.com/linweiyuan/archlinux-install-script</a><br>todo: 异常判断，选项改 whiptail</p><p>包缓存：flexo</p><p>内网 dns：dnsmasq</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=603487924&bvid=BV1VB4y177EU&cid=842532702&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;脚本：&lt;a href=&quot;https://github.com/linweiyuan/archlinux-install-script&quot;&gt;https://github.com/linweiyuan/archlinux-install-script&lt;/a&gt;&lt;br&gt;todo: 异</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Arch Linux" scheme="https://linweiyuan.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK18的UTF-8</title>
    <link href="https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html"/>
    <id>https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html</id>
    <published>2022-03-24T07:07:34.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JEP-400-UTF-8-by-Default"><a href="#JEP-400-UTF-8-by-Default" class="headerlink" title="JEP 400: UTF-8 by Default"></a>JEP 400: UTF-8 by Default</h1><p>JDK18 里有一项改进叫：<a href="https://openjdk.org/jeps/400">JEP 400: UTF-8 by Default</a></p><p>其实是将默认字符集改为 UTF-8，只是 Charset.defaultCharset() 返回 UTF-8，在这之前的 JDK 版本中，返回的字符集根据操作系统的不同会不一样，有可能会导致乱码，可以看到这个方法的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br><span class="line"></span><br><span class="line">The <span class="keyword">default</span> charset is UTF-<span class="number">8</span>, unless changed in an implementation specific manner.</span><br></pre></td></tr></table></figure><p>之前的版本只有这一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br></pre></td></tr></table></figure><p>所以并不是改了 String 的实现</p><h1 id="JEP-254-Compact-Strings"><a href="#JEP-254-Compact-Strings" class="headerlink" title="JEP 254: Compact Strings"></a>JEP 254: Compact Strings</h1><p>Java 中的 String 默认采用 UTF-16 字符集，这其实是历史的包袱，为了要支持新版本的 Unicode，又要保证向后兼容，因为谁也想不到计算机的发展是如此迅猛，当时是足够用了</p><p>如今用了 UTF-16，可以存大部分辅助字符（Emoji 等）了，但是对于西方国家，日常的简单字母，有点浪费</p><p>因此 JDK9 进行了改动，将底层 char[] 改为 byte[]，并且在原有基础上加入了 Latin-1（ISO-8859-1）字符集，详细可以看这个 JEP：<a href="https://openjdk.org/jeps/254">JEP 254: Compact Strings</a></p><p>String(UTF-16 + Latin-1)，其中内部多了个字段 coder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br></pre></td></tr></table></figure><p>当无法用 Latin-1 表示的时候，才使用 UTF-16，减少了内存的浪费</p><p>所以 JEP 400 和 String 本身的实现关系不大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JEP-400-UTF-8-by-Default&quot;&gt;&lt;a href=&quot;#JEP-400-UTF-8-by-Default&quot; class=&quot;headerlink&quot; title=&quot;JEP 400: UTF-8 by Default&quot;&gt;&lt;/a&gt;JEP 400: UTF-</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="JDK18" scheme="https://linweiyuan.github.io/tags/JDK18/"/>
    
  </entry>
  
  <entry>
    <title>ELK相关知识点</title>
    <link href="https://linweiyuan.github.io/2022/03/04/ELK%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2022/03/04/ELK%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2022-03-04T09:19:10.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><p>何为 ELK，Elasticsearch + Logstach + Kibaba</p><ul><li>Elasticsearch：存储，计算，搜索数据</li><li>Logstash：数据抓取</li><li>Kibaba：数据可视化</li></ul><h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>要说倒排索引，首先要从正向索引谈起，比如 MySQL</p><p>MySQL 这类关系型数据库，如果搜索 ID，会直接走索引（索引设置得正确的前提下），一旦走了索引，查询起来是很快的，但是如果是模糊查询，就不一定了，需要逐行扫描，在索引设置得不好的情况下，需要全表扫描，数据量大的场景下效率非常低</p><p>倒排索引中有两个重要的概念：</p><ul><li>文档（Document）：ES 里保存的数据，其中的每一条数据就是一个文档，类似数据库的一条记录</li><li>词条（Term）：对数据进行分词后得到的有意义的词语</li></ul><p>倒排索引是对正向索引的一种特殊处理：</p><ul><li>将文档数据利用分词算法，得到一堆的词条</li><li>ES 里保存的每行数据包括词条，词条所在文档 ID 等信息</li><li>因为词条具有唯一性，可以给词条创建索引</li></ul><p>搜索流程：</p><ul><li>发起搜索请求</li><li>分词得到词条</li><li>根据词条拿到 ES 里的文档 ID（这个 ID 会和 MySQL 里的 ID 同步）</li><li>根据 ID （去 MySQL）拿到具体数据</li></ul><p>虽然需要查两遍，先查倒排索引，再查正向索引，但因为都走了索引，所以非常快，无需全表扫描</p><p>两者的关系如下表</p><table><thead><tr><th align="center">MySQL</th><th align="center">Elasticsearch</th></tr></thead><tbody><tr><td align="center">table</td><td align="center">index</td></tr><tr><td align="center">row</td><td align="center">document</td></tr><tr><td align="center">column</td><td align="center">field</td></tr><tr><td align="center">schema</td><td align="center">mapping</td></tr><tr><td align="center">sql</td><td align="center">dsl</td></tr></tbody></table><p>两者不能比较，关注的领域不同，MySQL 擅长事务类型操作，可以确保数据的安全和一致性，ES 则擅长海量数据的搜索，分析，计算，实际上往往两者结合使用</p><h1 id="IK-分词器"><a href="#IK-分词器" class="headerlink" title="IK 分词器"></a>IK 分词器</h1><ul><li>ik_smart：只能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><h1 id="ES-搜索高亮"><a href="#ES-搜索高亮" class="headerlink" title="ES 搜索高亮"></a>ES 搜索高亮</h1><ul><li>给文档中的关键字加一个标签</li><li>页面给这个标签设置 高亮 CSS</li></ul><h1 id="ES-集群"><a href="#ES-集群" class="headerlink" title="ES 集群"></a>ES 集群</h1><p>不管什么集群，集群无非解决几个问题</p><ul><li>海量数据存储</li><li>单点故障</li></ul><p>ES 通过对数据进行分片，存储到不同的节点中，将备份放到对方节点，完成互相备份，当集群中的某个节点挂掉后，会立即将挂掉的节点上的分片数据迁移到其他节点，确保数据安全</p><h1 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h1><p>可以使用 Kibana 直接操作，或者 Cerebro</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELK&quot;&gt;&lt;a href=&quot;#ELK&quot; class=&quot;headerlink&quot; title=&quot;ELK&quot;&gt;&lt;/a&gt;ELK&lt;/h1&gt;&lt;p&gt;何为 ELK，Elasticsearch + Logstach + Kibaba&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elasticsearc</summary>
      
    
    
    
    <category term="ELK" scheme="https://linweiyuan.github.io/categories/ELK/"/>
    
    
    <category term="Elasticsearch" scheme="https://linweiyuan.github.io/tags/Elasticsearch/"/>
    
    <category term="Logstash" scheme="https://linweiyuan.github.io/tags/Logstash/"/>
    
    <category term="Kibana" scheme="https://linweiyuan.github.io/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ相关知识点</title>
    <link href="https://linweiyuan.github.io/2022/02/17/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2022/02/17/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2022-02-17T08:54:15.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>publisher：生产者（建立连接 -&gt; 创建 channel -&gt; 声明队列 -&gt; 发送消息 -&gt; 关闭连接和 channel）</li><li>consumer：消费者（建立连接 -&gt; 创建 channel -&gt; 声明队列 -&gt; 订阅消息）</li><li>exchange：交换机，负责消息路由<ul><li>Fanout Exchange：广播（所有绑定到该交换机的队列都能收到消息）</li><li>Direct Exchange：路由（根据 routingKey 来发送到指定的队列）</li><li>Topic Exchange： 主题（通过 routingKey 通配符来发送到指定的队列，#匹配一个或对个，*匹配一个）</li></ul></li><li>queue：队列，存储消息<ul><li>基本消息队列 BasicQueue：一对一</li><li>工作消息队列 WorkQueue：一对多</li></ul></li><li>virtualHost：虚拟主机，消息隔离</li></ul><h2 id="WorkQueue（TaskQueue）任务模型"><a href="#WorkQueue（TaskQueue）任务模型" class="headerlink" title="WorkQueue（TaskQueue）任务模型"></a>WorkQueue（TaskQueue）任务模型</h2><p>多个消费者绑定到一个队列，共同消费队列中的消息</p><ul><li>默认是平均给每个消费者，如果考虑消费者的处理能力，需要设置 prefetch 属性，每次获取一条，消费一条再获取，达到能者多劳的目的</li><li>同一条消息只会被一个消费者处理</li></ul><h2 id="发布-x2F-订阅模型"><a href="#发布-x2F-订阅模型" class="headerlink" title="发布&#x2F;订阅模型"></a>发布&#x2F;订阅模型</h2><p>对比 WorkQueue，多了一个 exchange 交换机</p><ul><li>生产者发送消息不是发送到队列，而是发送至交换机</li><li>消费者订阅队列</li><li>exchange 只负责转发消息，不会对消息进行存储，如果没有正确配置队列或路由规则，消息就会丢失</li></ul><h1 id="如何保证消息可靠性"><a href="#如何保证消息可靠性" class="headerlink" title="如何保证消息可靠性"></a>如何保证消息可靠性</h1><p>要确保发送的消息至少被消费一次，需要从源头开始，生产者是否成功发送消息到交换机，交换机是否正常发送消息到队列，队列里的消息是否成功被消费者消费</p><p>RabbitMQ 提供了 publisher confirm 和 publish-return 机制来避免消息在发送的过程中丢失</p><ul><li><p>publish-confirm</p><ul><li>如果消息成功投递到交换机，返回 ack</li><li>如果消息未投递到交换机，返回 nack</li></ul></li><li><p>publish-return</p><ul><li>如果消息投递到交换机了，但是没有路由到队列，返回 ack 及路由失败原因</li></ul></li></ul><p>考虑到 MQ 本身的稳定，可以分别将交换机，队列，消息都设置为持久化</p><h1 id="如何解决消息堆积问题"><a href="#如何解决消息堆积问题" class="headerlink" title="如何解决消息堆积问题"></a>如何解决消息堆积问题</h1><p>当发送消息超过了处理消息的速度，就会造成消息堆积，如果队列中的消息达到上限，那么最早受到的消息，可能就会变成死信，然后被丢弃</p><p>消息堆积的本质是消费者消费消息的速度跟不上，所以可以从下面几个方面来进行考虑</p><ul><li>增加消费者个数，那么速度就成倍提高了</li><li>增加队列长度，可以暂存更多的消息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;publisher：生产者（建立连接 -&amp;gt; 创建 channel -&amp;gt; 声明队列 -&amp;gt; 发送消</summary>
      
    
    
    
    <category term="消息队列" scheme="https://linweiyuan.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://linweiyuan.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis相关知识点</title>
    <link href="https://linweiyuan.github.io/2022/01/09/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2022/01/09/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2022-01-09T06:03:16.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis：Remote-Dictionary-Server"><a href="#Redis：Remote-Dictionary-Server" class="headerlink" title="Redis：Remote Dictionary Server"></a>Redis：Remote Dictionary Server</h1><ul><li>基于内存，速度非常快（因此受物理内存大小限制）</li><li>数据结构非常丰富（String， List， Hash， Set， SortedSet）</li><li>单线程，避免了线程切换和锁机制的性能消耗</li><li>可持久化（RDB + AOF）</li><li>支持发布订阅</li><li>支持 Lua 脚本</li><li>支持分布式锁</li><li>支持原子操作和事务</li><li>支持主从复制（Master-Slave）和高可用（Redis Sentinel）（3.0 版本以上）</li><li>支持管道（管道在这里类似于 batch，一次性发送多个命令，一次性返回所有结果，减少网络开销）</li></ul><h1 id="主要的五种数据结构及使用场景"><a href="#主要的五种数据结构及使用场景" class="headerlink" title="主要的五种数据结构及使用场景"></a>主要的五种数据结构及使用场景</h1><p>Redis 支持多种数据结构，常用的有 5 种</p><ul><li>String：计数器，kv 存储，限流，分布式锁</li><li>List：当队列来使用（lpush + rpop 或者 rpush + lpop）；发红包（抢红包是入队，拆红包则是出队）；列表（朋友圈点赞，评论）</li><li>Hash：kv，比如存一些标签信息，在保存用户信息等的场景，Hash 和 String 的不同点在于，String 要修改某个字段必须将整条用户完整信息取出来，再进行系列化反序列化操作，而 Hash 可以只对某个字段进行修改，节省了网络流量，不过 Hash 要比 String 占用多一点内存；购物车（用户 id，商品 id，商品数量）；存储对象</li><li>Set：好友、关注、粉丝、感兴趣的人的集合（sinter 获取交集，sismember 判断是否存在，scard 获取数量）；首页随机推荐展示（srandmember）；存储需要去重的场景，比如中奖，保证不会中两次</li><li>SortedSet：排行榜（因为有序）</li></ul><h1 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h1><ul><li>Redis 是完全基于内存的，所以读写效率非常高，当然 Redis 存在持久化操作，但 Redis 的持久化操作是通过 fork 子进程和利用 Linux 系统的页缓存技术来完成，所以并不会影响 Redis 的性能</li><li>对于 Redis 来说，它的性能瓶颈主要在网络和 IO 上，而不在 CPU，多线程频繁进行上下文切换会带来额外的性能消耗，可能会造成负优化；Redis 高版本也支持多线程，但是主要是用来执行对一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程的阻塞时间，提高执行的效率</li><li>数据结构设计得合理高效</li><li>采用了非阻塞 IO 多路复用机制：IO 多路复用是利用 select、poll、epoll 可以同时监测多个流的 IO 事件的能力，在空闲的时候，会阻塞当前线程，当有 IO 事件发生时才唤醒来处理就绪的流，这样就避免了大量的无用操作</li></ul><h1 id="数据过期淘汰策略"><a href="#数据过期淘汰策略" class="headerlink" title="数据过期淘汰策略"></a>数据过期淘汰策略</h1><p>Redis 中数据过期淘汰策略采用的是定期删除 + 惰性删除</p><ul><li>定期删除（activeExpireCycle）：Redis 后台有一个定时器来定时监视所有的 key，过期就删除。通过定期删除策略，可以保证过期的 key 最后都会被删掉，缺点就是每次都要都遍历 Redis 中的所有 key，非常消耗 CPU 资源，如果 key 过期了，但是定时器还没开始工作，这个过期的 key 就还能用</li><li>惰性删除（expireIfNeeded）：在使用 key 时，先判断 key 是否过期，如果过期则删除。这种方式也有缺点，就是虽然这个 key 过期了，但是一直没人用，那么它就会一直存在 Redis 中，造成浪费</li></ul><p>因此 Redis 将这两种方式结合起来，定时随机抽取一些幸运 key 进行删除</p><p>这样没有缺点吗？</p><p>有，如果某个 key 是天选之子，每次都抽不到，但是已经过期了，就会常驻内存</p><p>所以 Redis 还会有另外的机制来处理这种情况，就是内存淘汰</p><h1 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h1><p>volatile：设置过期时间的 key<br>allkeys：全部 key<br>lru：最近最少使用<br>lfu：最近最不经常使用<br>random：随机<br>ttl：过期时间<br>noeviction：永不过期</p><p>排列组合：</p><ul><li>volatile-lru</li><li>allkeys-lru</li><li>volatile-lfu</li><li>allkeys-lfu</li><li>volatile-random</li><li>allkeys-random</li><li>volatile-ttl</li><li>noeviction</li></ul><p>默认是永不过期，如果满了就会报 OOM</p><h1 id="Redis-和-Memcached-的区别"><a href="#Redis-和-Memcached-的区别" class="headerlink" title="Redis 和 Memcached 的区别"></a>Redis 和 Memcached 的区别</h1><ul><li>存储方式不同：Memcachedb 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部分存在硬盘上，这样能保证数据的持久性</li><li>数据类型支持：Memcached 对数据类型支持相对简单；Redis 有复杂的数据类型</li></ul><h1 id="为什么要使用-Redis-而不用-map-x2F-guava-做缓存"><a href="#为什么要使用-Redis-而不用-map-x2F-guava-做缓存" class="headerlink" title="为什么要使用 Redis 而不用 map&#x2F;guava 做缓存"></a>为什么要使用 Redis 而不用 map&#x2F;guava 做缓存</h1><p>缓存分为本地缓存和分布式缓存</p><p>map 或者 guava 实现的是本地缓存，这种缓存是存在内存中的，一旦 JVM 挂了或手动停掉，数据就丢失了，本地缓存无法做到多实例共享，因为每个实例都有自己的一份，生命周期和 JVM 绑定</p><p>Redis 或者 Memcached 则称为分布式缓存，支持多实例共享，Redis 还支持数据持久化，宕机数据还在</p><h1 id="Redis-三大经典问题"><a href="#Redis-三大经典问题" class="headerlink" title="Redis 三大经典问题"></a>Redis 三大经典问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询一个数据库不存在的数据，因为数据库没有，所以不能将数据库值缓存起来，导致每次请求都直接去到数据库，Redis 形同虚设</p><p>解决方案：</p><ul><li><p>缓存空值<br>当请求的数据库不存在于 Redis 中也不存在于数据库时，设置一个默认空值，后续再进行查询时就直接返回，避免请求去到数据库，除此之外还需要对该数据设置一个合适的过期时间，不然后续这个 key 的数据在数据库有了，永远不能被查到</p></li><li><p>布隆过滤器<br>在数据写入数据库的同时，将这个 ID 同步到布隆过滤器中，当请求的 ID 不存在布隆过滤器中，则说明该请求查询的数据一定没有在数据库中保存，就不要再去查数据库</p><ul><li>原理：首先分配一块数组，里面的值全为 0，当存入元素时，采用 N 个哈希函数对该元素进行哈希计算，映射出来的位置全部设置为 1；当检查这个 key 是否存在时，也是同样的方法，如果得到的全为 1，则 key 存在；布隆过路器存的只是这个 key 计算出来的哈希值，并不是这个 key 本身，而哈希函数是会出现碰撞的，所以就算计算出来全是 1，也不能保证其实这个 key 存在，也就是会出现判断 key 存在，但实际不存在的的情况，存在误判；反之，当判断这个 key 不存在的时候，就一定不存在</li></ul></li><li><p>对于恶意构造的请求</p><ul><li>对参数进行校验，非法则拦截</li><li>拉黑 IP（治标不治本）</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>高并发流量，访问的这个数据是热点数据，请求的数据在数据库中存在，但是 Redis 存的那一份已经过期，后端需要从数据库加载数据并写到 Redis（单一热点数据、高并发、数据失效）</p><ul><li>解决方案：<ul><li>设置随即过期时间：让缓存数据慢慢过期</li><li>缓存预热：提前把热门数据存入 Redis，设置一个较大的过期时间</li><li>锁机制：当发现缓存失效时，需要先获取锁，成功后才执行数据库查询和写数据到缓存的操作，失败则说明当前有其他线程在对数据库进行操作，休眠一段时间再重试</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>分两种情况</p><p>Redis 中大量数据同时失效，高并发场景下，大量的请求直接去到数据库，造成数据库压力激增，严重的话会搞挂数据库</p><ul><li>解决方案：<ul><li>设置随即过期时间，避免大量数据同时过期</li><li>对非核心业务的接口进行限流，避免过多请求直接被去到数据库</li><li>后台开启时任务，在缓存快要失效时及时更新缓存（具体问题具体分析）</li></ul></li></ul><p>Redis 挂了，也会使请求全部去到数据库</p><ul><li>解决方案：<ul><li>将热点数据均匀分布在不同的节点上</li><li>服务熔断和限流</li><li>构建高可用集群</li></ul></li></ul><p>缓存击穿和缓存雪崩的最大区别就是单一热点数据失效，还是大量数据同时失效</p><p>总之把握前中后的原则去进行系统设计和考虑</p><p>故障之前，尽可能集群部署，放置单点故障<br>发生了故障，对服务进行限流、降级操作，避免搞挂 MySQL<br>修复了故障后，通过 Redis 持久化机制 RDB 和 AOF，恢复缓存数据</p><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><ul><li>RDB（Redis Database Backup file）：Redis 快照文件，里面是一些二进制的数据，通过 save、bgsave 等命令进行保存，宕机恢复起来较快，文件体积也小，有压缩</li><li>AOF（Append Only File）：对 Redis 操作的每一条写命令都会记录起来，是纯文本，人可以看，故障恢复时，重新跑记录的命令，因为记录每一条命令，所以体积会较大</li></ul><p>Redis 支持同时开启 RDB 和 AOF，在这种情况下，会优先利用 AOF 文件来恢复数据，因为 AOF 文件保存了每一条记录，相对来说数据完整性高一点</p><h1 id="Redis-主从"><a href="#Redis-主从" class="headerlink" title="Redis 主从"></a>Redis 主从</h1><p>单节点 Redis 的并发能力有上限，搭建主从集群可以提高并发能力，实现读写分离<br>只有 master 节点可以执行写操作，slave 节点只能执行读操作</p><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>主从同步分为全量同步和增量同步</p><ul><li>全量同步<br>当 slave 第一次连接到 master 时，会执行一次全量同步，这个时候 master 会将内存中的数据生成快照 RDB，并发送给 slave，后续通过发送保存在 repl_backlog 的命令给 slave 完成增量同步<br>怎么知道是不是第一次连接？<br>master 和 slave 都有一个 replication id，如果不一致，则是第一次同步，那么 slave 就会修改自己的 id 为 master 的 id<br>如果 slave 断开太久，导致 offset 差太多，也要全量同步，offset 可以简单理解为 slave 和 master 的数据相差的量，详细的话记不清了，有个圆环什么的，如果在圆上走了一圈数据还没同步过去，那圆上的数据就会被覆盖，为了保证数据的一致性，就要全量同步</li><li>增量同步<br>slave 把 offset 发给 master，master 去 repl_backlog 里查看，并发送 offset 之后的命令给 slave</li></ul><h1 id="Redis-Sentinel-哨兵机制"><a href="#Redis-Sentinel-哨兵机制" class="headerlink" title="Redis Sentinel 哨兵机制"></a>Redis Sentinel 哨兵机制</h1><p>Sentinel 是 Redis 的高可用解决方案，用来对 Redis 主从节点进行监控，发生故障时通过投票机制选举出新的 master，并将所有 slave 连接到新的 master 上</p><p>哨兵也是一个 Redis 服务器，运行的是 redis-sentinel 命令，而普通 redis 服务运行的则是 redis-server 命令</p><p>哨兵不提供数据服务，通常配置成单数，可以运行多个实例组成一个分布式系统</p><p>对于一些起监控作用的中间件，完成的事情无非就是下面几个：</p><ul><li>监控：确保主从节点正常运行</li><li>通知：出现问题时发出通知</li><li>故障转移：选举新 master，将其他 slave 连接到新的 master 上</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis：Remote-Dictionary-Server&quot;&gt;&lt;a href=&quot;#Redis：Remote-Dictionary-Server&quot; class=&quot;headerlink&quot; title=&quot;Redis：Remote Dictionary Server&quot;&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://linweiyuan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>线程相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/10/24/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/10/24/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-10-24T15:13:13.000Z</published>
    <updated>2022-09-27T02:07:30.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>初始状态 new</li><li>可运行&#x2F;运行状态 runnable</li><li>休眠状态 blocked waiting timed_waiting</li><li>终止状态 terminated</li></ul><h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><ul><li>创建：new</li><li>就绪：start()，可运行，等待获取 CPU 的使用权</li><li>运行：执行</li><li>阻塞：放弃 CPU 使用权，sleep，wait（sleep 是 Thread 的，wait 是 Object 的）</li><li>死亡：执行完或异常退出</li></ul><h1 id="线程的-run-和-start-的区别"><a href="#线程的-run-和-start-的区别" class="headerlink" title="线程的 run() 和 start() 的区别"></a>线程的 run() 和 start() 的区别</h1><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，run() 可以重复调用，而 start() 只能调用一次，如果直接调用线程的 run() 方法，相当于执行一个普通方法，不在整个线程的生命周期中</p><h1 id="如何停止一个线程"><a href="#如何停止一个线程" class="headerlink" title="如何停止一个线程"></a>如何停止一个线程</h1><ul><li>使用 flag</li><li>stop()</li><li>interrupt()</li></ul><h1 id="sleep-wait-join-yield"><a href="#sleep-wait-join-yield" class="headerlink" title="sleep(), wait(), join(), yield()"></a>sleep(), wait(), join(), yield()</h1><ul><li>sleep: Thread 类的静态方法，不依赖于 synchronized，一般用于当前线程休眠，会释放锁</li><li>wait: Object 类的普通方法，依赖于 synchronized，一般用于多线程之间的通信，不会释放锁，要使用 notify() 或者 notifyAll() 唤醒</li><li>yield: 执行后线程进入就绪状态，马上释放了 CPU 的执行权，但是保留了 CPU 的执行资格，可能在下次调度的时候再次获得执行权</li><li>join: 执行后线程进入阻塞状态，让 join 的线程先执行完或中断</li></ul><h1 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify() 和 notifyAll() 的区别"></a>notify() 和 notifyAll() 的区别</h1><p>notify() 随机唤醒一个线程，notifyAll() 唤醒所有的线程，当 notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，不成功则留在锁池等待锁释放后再次参与竞争</p><h1 id="实现多线程的几种方式"><a href="#实现多线程的几种方式" class="headerlink" title="实现多线程的几种方式"></a>实现多线程的几种方式</h1><ul><li>继承 Thread 类（实际上 Thread implements Runnable）</li><li>实现 Runnable 接口</li><li>实现 Callable 接口（通过 FutureTask 包装器来创建）</li><li>通过线程池创建线程，使用线程池接口 ExecutorService 结合 Callable，Future 实现有返回值的多线程</li></ul><p>runnable 有两个弊端（Callable 和 Runnable 的最大区别就是 Callable 可以有返回值）：</p><ul><li>不能获取返回结果</li><li>不能抛出异常</li></ul><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程是运行在后台的一种特殊进程，为所有非守护线程提供服务，比如 GC 线程就是特殊的守护线程</p><p>用法注意：thread.setDaemon(true) 必须在 thread.start() 之前设置，否则抛出异常 IllegalThreadStateException，因为不能把正在运行的常规线程设置为守护线程</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 不是多线程同步机制中的一种，而是一种解决思路，它解决的是多线程下成员变量的安全问题，不是共享变量的安全问题</p><p>线程同步机制是多个线程共享一个变量，而 ThreadLocal 是每个线程创建一个自己的单独变量副本，所以每个线程都可以独立地改变自己的变量副本，而不会影响到其他线程的变量副本</p><p>ThreadLocal 内部有一个非常重要的内部类：<code>ThreadLocalMap</code>，是真正实现线程隔离机制的关键，ThreadLocalMap 内部结构类似于 Map，由键值对 key 和 value 组成一个 entry，key 为 ThreadLocal 本身，value 是对应的线程变量副本（首先是 Thread，Thread 里面有 ThreadLocal.ThreadLocalMap，Map 的话存储的是 Entry 集合，每一个 Entry 的 key 为 ThreadLocal，value 为具体的值）</p><p>有两点需要注意</p><ul><li>ThreadLocal 本身不存储值，它只是提供一个查找到值的 key</li><li>ThreadLocal 包含在 Thread 中，不是 Thread 包含在 ThreadLocal 中</li></ul><p>ThreadLocalMap 和 HashMap 的功能类似，但是实现上却有很大的不同：</p><ul><li>HashMap 的数据结构是数组 + 链表</li><li>ThreadLocalMap 的数据结构仅仅是数组</li><li>HashMap 是通过链地址法来解决哈希冲突，ThreadLocalMap 是通过开放地址法来解决哈希冲突（链地址：数组加链表，开放地址：寻找空的位置）</li><li>HashMap 里面的 Entry 内部类的引用都是强引用，ThreadLocalMap 里面的 Entry 内部类中的 key 是弱引用，value 是强引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt;</span><br></pre></td></tr></table></figure><p>从源码可以看出 ThreadLocal.ThreadLocalMap.Entry 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用，也就是说，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候 key 会被清理掉，而 value 不会被清理，这样一来，ThreadLocalMap 中就会出现 key 的 null 的 Entry，假如不做任何措施的话，value 永远无法被 GC，这个时候就可能产生内存泄漏</p><p>如何避免内存泄漏？</p><p>当一个变量不用的时候，要调用 remove() 删除掉（内部调用了 expungeStaleEntry()，将 value 设为 null，这样下一次垃圾回收时就会被彻底回收掉）</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 全称 Compare And Swap，比较并交换，是一条 CPU 的并发原语</p><p>原语的执行必须是连续的，在执行的过程中不允许被中断，因此不会造成数据不一致的问题，具有原子性。CAS 是一种重要的同步思想，判断内存中的值是否和预期的值一样，如果是，则将内存中的值更新为新值，否则会不断重试，直到一致为止</p><p>ABA 问题</p><p>比较并交换的循环，存在一个时间差，而这个时间差可能带来意想不到的问题</p><p>比如两个线程 A 和 B</p><ul><li>一开始都从主内存中拷贝了原值为 1</li><li>线程 A 执拿到值为 1 然后挂起</li><li>线程 B 修改值为 2，执行完毕</li><li>线程 B 觉得修改错误，把值重新设置为 1，</li><li>线程 A 被唤醒，比较发现内存中的值和预期的值一样，修改成功（但是不知道这个值已经被 B 修改过了）</li></ul><p>尽管线程 A CAS 操作成功，但不代表没有问题，有的需求，只注重头和尾，只要首尾一致，就接受，但是有的需求，还看重过程，中间不能发生任何修改，这就引出了 AtomicStampedReference 原子引用</p><p>AtomicStampedReference 内部维护了一个版本号 <code>stamp</code>，在进行 CAS 操作的时候，不仅要比较当前值，还要比较版本号，只有两者都相等，才执行更新操作（有点类似乐观锁）</p><p>任何技术都不是完美的，CAS 也有自己的缺点，CAS 实际上是一种自旋锁</p><ul><li>一直循环，开销比较大</li><li>只能保证一个变量的原子操作，多个变量依然要加锁</li><li>引出了 ABA 问题（AtomicStampedReference 可解决）</li></ul><p>CAS 的使用场景适合在一些并发量不高，线程竞争较少的情况，但是一旦线程冲突严重的情况，循环时间太长，会给 CPU 带来很大的开销</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><p>JDK 中提供了创建线程池的类，<code>Executors</code>，但是一般不推荐</p><p>Executors 类只是个静态工厂，提供创建线程池的几个静态方法（内部屏蔽了线程池参数配置细节），而真正的线程池类是 <code>ThreadPoolExecutor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize，</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize，</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime，</span></span><br><span class="line"><span class="params">  TimeUnit unit，</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue，</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory，</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>核心参数：</p><ul><li>corePoolSize：核心线程数。如果等于 0，则任务执行完毕后，没有任务请求进入时，销毁线程池中的线程。如果大于 0，即使本地任务执行完毕，核心线程也不会被销毁。设置得过大会浪费系统资源，设置过小会导致线程频繁创建</li><li>maximumPoolSize：最大线程数。必须大于等于 1，且大于等于 corePoolSize。如果与 corePoolSize 相等，则线程池大小固定。如果大于 corePoolSize，则最多创建 maximumPoolSize 个线程执行任务</li><li>keepAliveTime：线程空闲时间。线程池中线程空闲时间达到 keepAliveTime 值时，线程会被销毁，直到剩下 corePoolSize 个线程为止。默认情况下，线程池的最大线程数大于 corePoolSize 时，keepAliveTime 才会起作用。如果 allowCoreThreadTimeOut 被设置为 true，即使线程池的最大线程数等于 corePoolSize，keepAliveTime 也会起作用（回收超时的核心线程）</li><li>unit：TimeUnit 表示时间单位</li><li>workQueue：缓存队列。当请求线程数大于 corePoolSize 时，线程进入 BlockingQueue 阻塞队列</li><li>threadFactory：线程工厂。用来生产一组相同任务的线程。主要用于设置生成的线程名词前缀，是否为守护线程以及线程的优先级等。设置有意义的名称前缀可以很快知道线程是由哪个线程工厂创建的，方便调试</li><li>handler：执行拒绝策略对象。当任务数达到缓存上限时（即超过 workQueue 参数能存储的任务数），执行拒绝策略，相当于限流保护</li></ul><p>上面复杂概念的简洁描述：</p><ul><li>如果线程池当前状态不是 running，直接拒绝</li><li>如果 worker &lt; pool，创建新线程</li><li>如果 worker &gt;&#x3D; pool，queue 未满，将任务添加到 queue</li><li>如果 pool &lt;&#x3D; worker &lt; max，并且 queue 已满，开启新线程</li><li>如果 worker &gt; max，并且 queue 已满，拒绝策略（默认直接抛异常）</li></ul><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><ul><li>FixedThreadPool：固定长度的线程池，核心线程数等于最大线程数，不存在空闲线程，keepAliveTime 为 0，可以控制线程的最大并发数，超出的线程会放到队列中</li><li>SingleThreadExecutor：单线程线程池，核心线程数和最大线程数都是 1，它只会用唯一的线程来执行任务，相当于串行执行，超出的线程会放到队列中</li><li>CachedThreadPool：可缓存的线程池，核心线程数为 0，最大线程数为 Integer.MAX_VALUE，如果数据过多，它会不断地创建新的线程，存在 OOM 风险，keepAliveTime 为 60，工作线程处于空闲状态超过 keepAliveTime 会回收线程</li><li>WorkStealingPool：JDK 1.8 引入，核心是工作窃取，没怎么见人用过</li><li>ScheduledThreadPool：用于定时执行任务的线程池</li></ul><p>禁止直接使用 Executors 创建线程池的原因（除 Executors.newWorkStealingPool 方法之外，其他方法都有 OOM 风险）：</p><ul><li>Executors.newCachedThreadPool 和 Executors.newScheduledThreadPool 两个方法最大线程数为 Integer.MAX_VALUE，如果线程数太多，会有 OOM 的风险</li><li>Executors.newSingleThreadPool 和 Executors.newFixedThreadPool 两个方法的 workQueue 参数为 LinkedBlockingQueue，容量为 Integer.MAX_VALUE，如果瞬间请求过大，导致队列中任务过多，会有 OOM 风险</li></ul><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><p>ThreadPoolExecutor 提供了四个公开的静态内部类：</p><ul><li>AbortPolicy：默认，丢弃任务并抛出 RejectedExecutionException</li><li>DiscardPolicy：丢弃任务，但是不抛出异常（不推荐）</li><li>DiscardOldestPolicy：丢弃队列中等待最久的任务，然后把当前的新任务加入到队列中</li><li>CallerRunsPolicy：调用任务的 run() 方法绕过线程池直接执行</li></ul><h2 id="如何自定义拒绝策略"><a href="#如何自定义拒绝策略" class="headerlink" title="如何自定义拒绝策略"></a>如何自定义拒绝策略</h2><p>实现 RejectedExecutionHandler 接口或继承已有策略，重写 rejectedExecution() 方法</p><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><p>线程池，数据库连接池，HTTP 连接池等都属于池化技术，主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务），每个线程池还维护一些基本统计信息例如已完成任务的数量</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高相应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;初始状态 new&lt;/li&gt;
&lt;li&gt;可运行&amp;#x2F;运行状态 runnable&lt;/li&gt;
&lt;li&gt;休眠状态 b</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="Thread" scheme="https://linweiyuan.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>JVM相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/10/01/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/10/01/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-10-01T13:53:27.000Z</published>
    <updated>2022-09-27T02:07:30.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h1><p>程序计数器里面存放的是下一条 JVM 指令代码的执行地址，概念上有点类似数据库结果集遍历时的游标，不断指向下一条，物理上是通过寄存器实现的，寄存区在 CPU 上是非常快的单元</p><p>在 JVM 的规范中，每条线程都有自己的程序计数器，所以程序计数器是线程私有的，因为当发生线程切换的时候，需要知道切换回来后下一步应该执行什么操作，如果不是线程私有则会造成混乱</p><p>程序计数器是 JVM 中唯一不会存在 OOM 的区域，这一点是 JVM 规范上要求的</p><hr><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>说虚拟机栈之前先说栈，栈的特点就是先进后出或后进先出</p><p>虚拟机栈是线程运行时需要的内存空间，线程运行的目的是为了执行代码，代码由一个个方法组成，当线程运行的时候，每个方法需要的内存空间就是栈帧（参数，局部变量，返回地址），每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，调用方法时入栈，执行完出栈，每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（栈顶部），栈是有一定的深度的，当发生递归死循环时，一直有方法入栈但不出栈，导致栈溢出，抛出 <code>java.lang.StackOverflowError</code></p><p>IDEA debug 时左下角的 Frame 就是栈帧，比较直观，从上到下，右边还可以看到栈内的局部变量值</p><h2 id="垃圾回收是否涉及栈内存"><a href="#垃圾回收是否涉及栈内存" class="headerlink" title="垃圾回收是否涉及栈内存"></a>垃圾回收是否涉及栈内存</h2><p>不会</p><p>栈内存随着出栈就释放掉，垃圾回收主要用来回收堆内存</p><h2 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h2><p>不是</p><p>-Xss size（比如-Xss1m，没有等号）</p><p>Windows 下取决于虚拟内存的设置，其他主流操作系统上默认为 1024KB（1MB）</p><p>物理内存的大小是固定的，栈内存分配设置得越大，占用越多内存，由于栈是线程私有的，所以线程占用的内存就会变大，那么操作系统可以创建的总线程数就会变小</p><p>比如操作系统 10M 内存（只是举例），本来一个线程默认占用 1M 内存，那么可以创建 10 个线程，但设置-Xss2m 后，只能创建 5 个线程了</p><p>-Xss 设置得大，只会增加方法递归调用的次数，一般不会提升性能，就是不容易爆栈，但死循环递归该爆还得爆</p><h2 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全"></a>方法内的局部变量是否线程安全</h2><p>是</p><p>每个线程都有私有的栈帧，里面会有各自独立的变量，互不干扰。线程安全问题出现在共享变量上，如果方法内局部变量没有逃离方法的作用范围，那么这个局部变量就是线程安全的</p><h2 id="线上诊断方法"><a href="#线上诊断方法" class="headerlink" title="线上诊断方法"></a>线上诊断方法</h2><p>通常都是十八般武艺配合着来用，包括但不限于：</p><ul><li>top 命令，查看 %CPU，配合 grep java</li><li>ps H -eo pid,tid,%cpu(小写 cpu) | grep 进程号</li><li>jstack 进程 id，会列出所有线程，有线程号 nid（16 进制），printf ‘%x’ 10 进制 id</li><li>jstack 查看是否出现死锁</li></ul><hr><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>native 地方法运行时所需要的空间，其他的每什么好说的了，不懂</p><hr><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>通过 new 关键字创建的对象都会使用堆内存<br>堆里面的对象是线程共享的，所以一般都需要考虑线程安全的问题，堆有垃圾回收机制，并且会发生内存溢出 <code>java.lang.OutOfMemoryError: Java heap sapce</code></p><p>JVM 参数常用的有两个，用于设置内存占用大小<br>-Xms：堆的初始大小<br>-Xmx：堆的最大占用</p><p>为什么一般都会将这两个参数设置成一样？<br>因为当堆内存不足需要进行扩容的时候，会发生内存抖动，对程序运行的稳定性会有一定的影响</p><h2 id="线上诊断方法-1"><a href="#线上诊断方法-1" class="headerlink" title="线上诊断方法"></a>线上诊断方法</h2><p>包括但不限于：</p><ul><li>jps：查看系统中存在的 Java 进程</li><li>jmap：查看堆内存占用情况，jmap -head pid</li><li>jconsole：图形界面的，多功能监测工具，可以连续监测（可测出是否发生死锁）</li><li>jvisualvm：堆 dump</li></ul><hr><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>线程共享，存放一些类的基本信息（类，类加载器，运行时常量池），逻辑上是堆的一部分，不同厂商有不同的实现</p><p>HotSpot 在 1.7 之前用永久代（堆），1.8 后用元空间（操作系统内存）</p><p>方法区是规范，永久代或者元空间是其中一种实现，方法区会发生内存溢出<br>1.8 以前会导致永久代内存溢出：<code>-XX:MaxPermSize=m（OutOfMemory：PermGen space）</code><br>1.8 之后会导致元空间内存溢出：<code>-XX:MaxMetaspaceSize=m（OutOfMemory：Metaspace）</code></p><hr><h1 id="字符串常量池，串池（StringTable）"><a href="#字符串常量池，串池（StringTable）" class="headerlink" title="字符串常量池，串池（StringTable）"></a>字符串常量池，串池（StringTable）</h1><p>常量池：是一张表，维护类名，方法名，参数类型，字面量等信息</p><p>运行时常量池：当类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><p>字符串常量池：字符串是日常开发中使用得非常多的类，池化技术某种程度上会有性能上的提升</p><p>如何判断字符串是在堆还是在串池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -v x.class 查看二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</p><p>不同的 JDK 版本可以看到反编译出来的不一样</p><p>JDK 1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Classfile /home/linweiyuan/Temp/test/Test.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Sep <span class="number">24</span>, <span class="number">2022</span>; size <span class="number">759</span> bytes</span><br><span class="line">  MD5 checksum 1eeb9a3b24c5c4f6a213e62ca4ee1691</span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">19</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">20</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">4.</span>#<span class="number">22</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">4.</span>#<span class="number">23</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">24</span>            <span class="comment">// Test</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">11</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">12</span> = Utf8               Code</span><br><span class="line">  #<span class="number">13</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               a</span><br><span class="line">  #<span class="number">20</span> = Utf8               b</span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">26</span>:#<span class="number">27</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">28</span>:#<span class="number">29</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">24</span> = Utf8               Test</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">26</span> = Utf8               append</span><br><span class="line">  #<span class="number">27</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">28</span> = Utf8               toString</span><br><span class="line">  #<span class="number">29</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">17</span>: aload_2</span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">24</span>: astore_3</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br></pre></td></tr></table></figure><p>JDK 9+，我这里用的是 JDK 17，但其实从 9 开始就变了，之前有试过，最近整理笔记，电脑上 JDK 9 已经没有了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Classfile /home/linweiyuan/Temp/test/Test.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Sep <span class="number">24</span>, <span class="number">2022</span>; size <span class="number">759</span> bytes</span><br><span class="line">  SHA-<span class="number">256</span> checksum 1f929ea79bba2fa30f55910a61ea7627d430b3dff13f7bdb8cd275e901a0343d</span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">61</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">15</span>                         <span class="comment">// Test</span></span><br><span class="line">  super_class: #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">2</span>, attributes: <span class="number">3</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = String             #<span class="number">8</span>             <span class="comment">// a</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               a</span><br><span class="line">   #<span class="number">9</span> = String             #<span class="number">10</span>            <span class="comment">// b</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               b</span><br><span class="line">  #<span class="number">11</span> = InvokeDynamic      #<span class="number">0</span>:#<span class="number">12</span>         <span class="comment">// #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">12</span> = NameAndType        #<span class="number">13</span>:#<span class="number">14</span>        <span class="comment">// makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               makeConcatWithConstants</span><br><span class="line">  #<span class="number">14</span> = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">16</span>            <span class="comment">// Test</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               Test</span><br><span class="line">  #<span class="number">17</span> = Utf8               Code</span><br><span class="line">  #<span class="number">18</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               main</span><br><span class="line">  #<span class="number">20</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">23</span> = Utf8               BootstrapMethods</span><br><span class="line">  #<span class="number">24</span> = MethodHandle       <span class="number">6</span>:#<span class="number">25</span>          <span class="comment">// REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">25</span> = Methodref          #<span class="number">26.</span>#<span class="number">27</span>        <span class="comment">// java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">26</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/invoke/StringConcatFactory</span></span><br><span class="line">  #<span class="number">27</span> = NameAndType        #<span class="number">13</span>:#<span class="number">29</span>        <span class="comment">// makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/invoke/StringConcatFactory</span><br><span class="line">  #<span class="number">29</span> = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #<span class="number">30</span> = String             #<span class="number">31</span>            <span class="comment">// \u0001\u0001</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               \u0001\u0001</span><br><span class="line">  #<span class="number">32</span> = Utf8               InnerClasses</span><br><span class="line">  #<span class="number">33</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #<span class="number">35</span> = Class              #<span class="number">36</span>            <span class="comment">// java/lang/invoke/MethodHandles</span></span><br><span class="line">  #<span class="number">36</span> = Utf8               java/lang/invoke/MethodHandles</span><br><span class="line">  #<span class="number">37</span> = Utf8               Lookup</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: aload_1</span><br><span class="line">         <span class="number">7</span>: aload_2</span><br><span class="line">         <span class="number">8</span>: invokedynamic #<span class="number">11</span>,  <span class="number">0</span>             <span class="comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">        <span class="number">13</span>: astore_3</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">24</span> REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #<span class="number">30</span> \u0001\u0001</span><br><span class="line">InnerClasses:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> #<span class="number">37</span>= #<span class="number">33</span> of #<span class="number">35</span>;    <span class="comment">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br></pre></td></tr></table></figure><p>得出结论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.9 -&gt; StringConcatFactory.makeConcatWithConstants()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// StringConcatFactory.makeConcatWithConstants()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 编译期优化</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false，因为 s3 存在串池中，s4 是 new 出来的对象在堆中</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true，因为 ab 已经存在串池中了（s3），对于确定的字符串（不是变量），Java 会进行编译期优化</span></span><br></pre></td></tr></table></figure><h2 id="StringTable-特性"><a href="#StringTable-特性" class="headerlink" title="StringTable 特性"></a>StringTable 特性</h2><ul><li>常量池中的字符串只是符号，第一次用到时才变为对象</li><li>利用串池的机制，可以避免重复创建字符串对象</li><li>字符串常量拼接的原理是编译期优化</li><li>用 intern() 可以主动把串池中还没有的字符串对象放入串池（尝试放入串池，有则不会放入，没有则放入，无论放入是否成功，返回的都是串池中的对象）</li></ul><p>这里有一个要注意的地方，JDK 1.8 intern() 将自己放入串池（一个对象），JDK 1.6 把自己复制一份放进串池（两个对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入了串池，并且返回了串池中的对象 ab</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true, 因为串池中还没有，intern() 放入了后，s 此时在串池中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 串池中已经有了 ab</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, 因为串池放入失败，s还在堆中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, ab 此时在串池中，s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, 因为串池放入失败，s 还在堆中</span></span><br></pre></td></tr></table></figure><h2 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h2><ul><li>1.6：常量池的一部分，位于永久代中（永久代 Full GC 才会触发，字符串用的场景很多，但是好多都是可以回收的，内存占用太多会造成永久代内存不足）（PermGen space）</li><li>1.8：堆中的一部分（堆 Minor GC 就会触发）（Heap space）</li><li>-XX:-UseFCOverheadLimit（+启用，-禁用，默认启用）：如果 98%的时间花在了垃圾回收上，但是只有 2% 的堆内存回收了，此时 JVM 直接抛出 <code>OutOfMemoryError：GC overhead limit exceeded</code></li></ul><h2 id="StringTable-性能调优"><a href="#StringTable-性能调优" class="headerlink" title="StringTable 性能调优"></a>StringTable 性能调优</h2><p>StringTable 本质上是一个哈希表，哈希表性能与桶的个数有关</p><ul><li>桶个数太大，元素分散，哈希碰撞机率减少，检索速度较快</li><li>桶个数太小，哈希碰撞机率增加，链表就会变长，查找速度就会降低</li></ul><p>可以通过 JVM 参数调整桶的个数，-XX:StringTableSize&#x3D;12345（最小值 1009）</p><hr><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>最快的 GC 是不发生 GC</p><h2 id="如何判断对象是否能回收"><a href="#如何判断对象是否能回收" class="headerlink" title="如何判断对象是否能回收"></a>如何判断对象是否能回收</h2><ul><li>引用计数法（有循环引用问题，A 引用 B，B 引用 A，都不会被回收，JVM 不是这种）</li><li>可达性分析算法（JVM 采用这种，GC Roots）<ul><li>哪种可作为 Roots？(可以用 Eclipse Memory Analyzer 查看，jps -&gt; jmap -dump:format&#x3D;b,live,file&#x3D;m.bin pid)<ul><li>System Class（核心的类，Object, HashMap, String 等）</li><li>Native Stack（操作系统方法执行时引用的 Java 对象）</li><li>Thread（活动线程）</li><li>Busy Monitor（被加锁的对象，回收了，就无法解锁）</li></ul></li></ul></li><li>四种引用<ul><li>强引用（new，赋值，沿着 GC Roots 能找到，就不会被回收）</li><li>软引用（没有强引用时，发生垃圾回收，如果内存不足，再执行一次，被回收，可配合引用队列使用释放自身）<ul><li>SoftReference</li><li>ReferenceQueue, new SoftReference(obj, queue)</li><li>当 obj 被回收时，进入队列</li><li>queue.poll() 获取自身，遍历 remove()</li></ul></li><li>弱引用（没有强引用时，只要发生了垃圾回收，被回收，可配合引用队列使用释放自身）<ul><li>WeakReference</li></ul></li><li>虚引用（必须配合引用队列使用，用于 NIO 中，由 Reference Handler 处理）<ul><li>PhantomReference</li></ul></li><li>终结器引用（必须配合引用队列使用，finalize() 后进入队列，由 Finalizer 处理）</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li>标记清除：速度较快，容易产生内存碎片（空间不连续，数组放不下）</li><li>标记整理：速度较慢，没有内存碎片，标记 -&gt; 清除 -&gt; 整理（会移动对象，因此对象的引用地址会变，需要做额外的工作来更新）</li><li>复制：没有内存碎片，需要占用双倍内存空间，将内存分成大小相等的两块（from, to）发生垃圾回收时，交换位置</li></ul><h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>新生代（朝生夕死）：</p><ul><li>eden</li><li>from</li><li>to</li></ul><p>垃圾回收过程（GC 都会 Stop The World，时间上新生代短一点，老年代长一点，暂停其他用户线程，让垃圾回收线程先执行完）</p><ul><li>新对象默认存放在 eden</li><li>当空间不足时，触发 Minor GC</li><li>标记-清除-复制，把存活的复制到 to（注意不是到 from），寿命加 1</li><li>交换 from to 位置（谁是空的谁就是 to）</li><li>继续放对象</li><li>…</li><li>eden 存活的复制到 to，寿命加 1</li><li>原来在 from 的移到存活后移到 to,寿命加 1</li><li>交换 from to 位置</li><li>…</li><li>寿命超过阈值（15，保存在对象头，4bit，最高 1111 -&gt; 15），晋升到老年代</li><li>如果老年代也放不下，先尝试 Minor GC, 内存还不够，触发 Full GC，再不够，抛出 OOM</li><li>大对象在新生代空间不够，但老年代空间够的情况下，直接晋升</li></ul><p>相关 JVM 参数</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td></tr><tr><td>-Xmx &#x2F; -XX:MaxHeapSize&#x3D;size</td><td>堆最大大小</td></tr><tr><td>-Xmn &#x2F; -XX:NewSize&#x3D;size, -XX:MaxNewSize&#x3D;size</td><td>新生代大小</td></tr><tr><td>-XX:InitialSurvivorRatio&#x3D;ratio, -XX:+UseAdaptiveSizePolicy</td><td>幸存区比例（动态）</td></tr><tr><td>-XX:SurvivorRatio&#x3D;ratio</td><td>幸存区比例</td></tr><tr><td>-XX:MaxTenuringThreshold&#x3D;threshold</td><td>晋升阈值</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>晋升详情</td></tr><tr><td>-XX:+PrintGCDetails -verbose:gc</td><td>GC 详情</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC 前 Minor GC</td></tr></tbody></table><p>线程内的 OOM 不会导致整个 JVM 挂掉</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><ul><li>串行<ul><li>单线程</li><li>适合堆内存较小，个人电脑，CPU 个数少（因为是单线程）</li><li>-XX:+UseSerialGC&#x3D;Serial+SerialOld</li></ul></li><li>吞吐量优先（1.8 默认）<ul><li>多线程</li><li>适合堆内存较大，多核 CPU</li><li>让单位时间内，STW 的时间最短</li><li>-XX:+UseParallelGC</li><li>-XX:+UseParallelOldGC</li><li>-XX:+UseAdaptiveSizePolicy</li><li>-XX:GCTimeRatio&#x3D;99 (1 &#x2F; 1 + ratio, 默认 99，0.01，100 分钟内只能一分钟用于垃圾回收，因为上一行配置了动态调整，所以一般会自动增加堆的大小，大小增加了，就能放更多的东西，垃圾回收的次数就会降低，吞吐量就会提高，一般设置 19)</li><li>-XX:MaxGCPauseMillis&#x3D;200（毫秒，和上面的配置冲突，只能取折中，因为堆增大了，虽然 GC 次数减少，但单次的时间会增加）</li><li>-XX:ParallelGCThreads&#x3D;n</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>适合堆内存较大，多核 CPU</li><li>尽可能让单次 STW 的时间最短</li><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+UseParNewGC SerialOld</li><li>-XX:ParallelGCThreads&#x3D;n</li><li>-XX:ConcGCThreads&#x3D;n</li><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</li><li>-XX:+CMSScavengeBeforeRemark</li></ul></li></ul><p>如何区分吞吐量优先和响应时间优先？</p><p>吞吐量优先：比如，每次花费 0.2 秒，一小时两次，共 0.4 秒，垃圾回收时间占比越低，吞吐量越高</p><p>响应时间优先：比如，每次只需 0.1 秒，但可能一小时发生了 5 次，共 0.5 秒</p><ul><li>G1（Garbage First，JDK 9 默认，废弃 CMS）<ul><li>同时注重吞吐量和低延迟，默认的暂停目标是 200ms</li><li>超大堆内存，将堆划分成多个大小相等的 Region</li><li>整体上是标记-整理，两个区域之间是复制</li><li>-XX:+UseG1GZ</li><li>-XX:G1HeapRegionSize&#x3D;size</li><li>-XX:MaxGCPauseMillis&#x3D;ms</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序计数器（Program-Counter-Register）&quot;&gt;&lt;a href=&quot;#程序计数器（Program-Counter-Register）&quot; class=&quot;headerlink&quot; title=&quot;程序计数器（Program Counter Register</summary>
      
    
    
    
    <category term="JVM" scheme="https://linweiyuan.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://linweiyuan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/07/04/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/07/04/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-07-04T13:25:16.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><ul><li>aop</li><li>beans</li><li>context</li><li>core</li><li>jdbc</li><li>test</li><li>web</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>分为四个阶段</p><ul><li>实例化</li><li>属性赋值</li><li>初始化</li><li>销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">doCreateBean() &#123;</span><br><span class="line">  <span class="comment">// InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span></span><br><span class="line">  createBeanInstance() <span class="comment">// 实例化</span></span><br><span class="line">  <span class="comment">// InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span></span><br><span class="line">  populateBean() <span class="comment">// 属性赋值</span></span><br><span class="line">  <span class="comment">// BeanPostProcessor.postProcessBeforeInitialization</span></span><br><span class="line">  initializeBean() <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// BeanPostProcessor.postProcessAfterInitialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aware 都是在初始化阶段之前调用的</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>单例：Bean 默认为单例模式</li><li>工厂：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例</li><li>代理：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 的字节码生成技术</li><li>模板方法：用来解决代码重复的问题，比如 RestTemplate，JpaTemplate</li><li>观察者：当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被强制更新，比如 ApplicationListener</li></ul><h1 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h1><p>指的是当多个事务同时存在的时候，Spring 如何处理这些事务的行为</p><p>propagation：</p><ul><li>required：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，最常用</li><li>requires_new：无论当前存不存在事务，都创建新事务</li><li>supports：如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li>not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li>never：以非事务方式执行，如果当前存在事务，则抛出异常</li><li>nested：如果当前存在事务，则在嵌套事务中执行，如果当前没有事务，则按 required 属性执行</li><li>mandatory：如果当前存在事务，就加入，不存在则抛出异常</li></ul><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul><li>isolation_default</li><li>isolation_read_uncommitted</li><li>isolation_read_committed</li><li>isolation_repeatable_read</li><li>isolation_serializable</li></ul><h1 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h1><ul><li>singleton：bean 在每个 Spring IoC 容器中只有一个实例</li><li>prototype：一个 bean 的定义可以有多个实例</li><li>request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效</li><li>session：在一个 http session 中，一个 bean 定义对应一个实例，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效</li><li>global-session：在一个全局的 http session 中，一个 bean 定义对应一个实例，该作用域仅在基 web 的 Spring ApplicationContext 情形下有效</li></ul><p>默认是 singleton，使用 prototype 作用域需要慎重的考虑，因为频繁创建和销毁 bean 会带来很大的性能开销</p><h1 id="单例-bean-是线程安全的吗"><a href="#单例-bean-是线程安全的吗" class="headerlink" title="单例 bean 是线程安全的吗"></a>单例 bean 是线程安全的吗</h1><p>不是，Spring 框架中的单例 bean 不是线程安全的</p><p>Spring 中的 bean 默认是单例模式，Spring 框架并没有对单例 bean 进行多线程的封装处理</p><p>实际上大部分时候 Spring bean 是无状态的（比如 dao），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view mode 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 singleton 改成 prototype 这样请求 bean 相当于 new bean，就可以保证线程安全</p><ul><li>有状态就是有数据存储功能</li><li>无状态就是不会保存数据</li></ul><p>那 Spring 如何处理线程并发问题的？</p><p>在一般情况下，只有无状态的 bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 bean 都可以声明为 singleton 作用域，因为 Spring 对一些 bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题</p><p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题，同步机制采用了时间换空间的方法，仅提供一份变量，不同的线程在访问前需要先获得锁，没获得锁的线程则需要排队</p><p>而 ThreadLocal 采用了空间换时间的方式，ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突，因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了，ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal</p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><ul><li>@Component：将 Java 类标记为 bean，是任何 Spring 管理组件的通用型，Spring 的组件扫描机制扫描并用 IoC 容器进行管理</li><li>@Controller：将类标记为 Spring Web MVC 控制器，会自动导入到 IoC 容器中</li><li>@Service：基本和 @Component 一样，只是用在 service 层的话，会更好地见名知意</li><li>@Repository：除了具有 @Component 的作用外，还具有额外的作用，可以将未经检查的异常转换为 Spring DataAccessException</li></ul><h1 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h1><ul><li>官方标准<ul><li>@Resource：JSR250，按名称或类型注入，不支持 @Primary</li><li>@Inject：JSR330，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合@Primary 可选择优先注入</li><li>@Autowired：Spring 自己的实现，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合 @Primary 可选择优先注入</li></ul></li></ul><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>除了 MySQL 四种事务隔离级别外，多了个默认，就是数据库是什么就是什么</p><ul><li>isolation_default</li><li>isolation_read_uncommitted</li><li>isolation_read_committed</li><li>isolation_repeatable_read</li><li>isolation_serializable</li></ul><h1 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h1><p>IoC 就是控制反转，它把传统的有程序代码直接 new 的对象的调用权交给 Spring 容器，通过容器来实现对象组件的装配和管理，所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器</p><p>Spring IoC 负责创建对象，管理对象，装配对象，配置对象，并且管理这些对象的整个生命周期</p><p>IoC 有什么作用？</p><ul><li>管理对象的创建和依赖关系的维护，对象的创建并不是一件简单的事，在对象管理比较复杂时，如果依赖关系需要程序代码来维护，比较痛苦</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>A 有 B，B 有 A<br>Bean 的创建过程：</p><ul><li>获取 bean 定义</li><li>通过反射创建原始对象</li><li>填充属性（这一步就是依赖注入）</li><li>完成对象的创建放到一级缓存</li></ul><p>A 创建的时候，通过 bean 的定义创建了一个原始对象，然后将 lambda 表达式放到三级缓存中，接着进行属性的填充，填充的时候发现 B 还没有，于是按照同样的方式来创建 B，等到 B 进行属性注入的时候，分别从一级，二级，三级缓存里面找 A，最后在三级缓存里面找到，于是将 A 放到二级缓存中，并从三级缓存中删除 A，此时的 A 是一个对象并未完成初始化好的对象，但是已经创建出来了，那么 B 属性注入成功，就放到一级缓存中，接着回到 A 的属性注入，注入完成 B 后，A 也完成了创建，就放到一级缓存中，并从二级缓存中删掉 A</p><p>为什么需要三级缓存来解决循环依赖？</p><p>如果是普通的对象，用一级缓存就可以，但是 Spring 的对象很多都是动态代理增强的，三级缓存里存的是一个 lambda 表达式，根据对象是否有动态代理的需求，进行包装返回，这时的对象是未完成初始化的，如果不放到二级缓存直接放到一级缓存，一级缓存里会出现既有初始化完成的 bean，又有未初始化完成的，管理起来就可能会出现不可预知的错误，也不符合单一职责原则。在缓存 bean 的过程中，三个级别的缓存都是互斥的，最终都会只保留一份完成初始化的 bean，放到一级缓存里</p><h1 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h1><ul><li>用户发送请求到前端控制器 DispatcherServlet</li><li>DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器请求获取 Handler</li><li>HandlerMapping 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器，返回给 DispatcherServlet</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器</li><li>HandlerAdapter 经过适配调用具体处理器 Handler，也叫后端控制器</li><li>Handler 执行完成，返回 ModelAndView</li><li>HandlerAdapter 将 Handler 执行结构 ModelAndView 返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析</li><li>ViewResolver 解析后返回具体 View</li><li>DispatcherServlet 对 View 进行渲染视图，即将模型数据填充至视图中</li><li>DispatcherServlet 响应用户</li></ul><h1 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h1><p>跨域可以在前端通过 JSONP 来解决，但是 JSNOP 只可以发送 GET 请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此推荐在后端通过 CORS Cross-Origin Resource Sharing 来解决跨域问题，Spring Boot 中可以通过实现 WebMvcConfigurer 接口，然后重写 addCordMappings 方法来解决跨域问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;aop&lt;/li&gt;
&lt;li&gt;beans&lt;/li&gt;
&lt;li&gt;context&lt;/li&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;jdbc&lt;</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Spring Boot" scheme="https://linweiyuan.github.io/tags/Spring-Boot/"/>
    
    <category term="Spring" scheme="https://linweiyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://linweiyuan.github.io/2021/06/28/MySQL%E4%BA%8B%E5%8A%A1.html"/>
    <id>https://linweiyuan.github.io/2021/06/28/MySQL%E4%BA%8B%E5%8A%A1.html</id>
    <published>2021-06-28T15:08:02.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务，首先要了解 ACID</p><h2 id="A-原子性"><a href="#A-原子性" class="headerlink" title="A 原子性"></a>A 原子性</h2><p>原子性体现在回滚上面，如果 SQL 执行出错，要把之前的状态恢复，那怎么知道恢复什么呢，把之前的状态保存在 undo log 里，出错则会执行相反的操作</p><h2 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C 一致性"></a>C 一致性</h2><p>事务执行完毕后，数据库的完整性约束并没有被破坏，主要是通过原子性 + 隔离性 + 持久性来保证</p><h2 id="I-隔离性"><a href="#I-隔离性" class="headerlink" title="I 隔离性"></a>I 隔离性</h2><p>写写操作是通过锁解决，写读操作是基于 MVCC</p><h2 id="D-持久性"><a href="#D-持久性" class="headerlink" title="D 持久性"></a>D 持久性</h2><p>指的是事务一旦提交，对数据库的改变就是永久性的</p><hr><p>MySQL 为了提高效率，会有一个 buffer，每次写到 buffer 中，再定期将 buffer 中的数据刷新到硬盘上，这就会有一个问题，如果 buffer 还没来得及刷盘，MySQL 宕机了，数据就会丢失，因此，引入了 redo log，当数据库的数据进行增删改的时候，先将 本次操作记录到 redo log 中，再写 buffer，这样如果宕机了，还有 redo log 来恢复数据，这样就保证了持久性</p><p>为什么 redo log 写数据要比 buffer 写数据库快？</p><p>因为 buffer 写盘是随机 IO，redo log 是追加的模式，是顺序 IO，效率就高，并且 buffer 持久化数据是以数据页 page 为单位的，默认是 16K，就是说一个数据页上的小小修改都要把整个数据页写入，redo log 只需要写入真正需要的部分，无效的 IO 就大大减少了，效率就提高了</p><p>读未提交：脏读，不可重复读，幻读都有可能出现</p><p>读已提交：避免脏读，可能出现不可重复读和幻读</p><p>重复读：避免脏读和不可重复读，可能出现幻读</p><p>串行化：全部避免，性能差</p><p>脏读: 一个事务修改了数据还没提交，另一个事务读到了旧数据</p><p>不可重复读: 一个事务多次读同一数据，间隔间，另一个事务把数据改了，导致两次读取结果不一样</p><p>幻读: 一个事务对全表数据进行修改，另一个事务往表中新增数据，修改完成后莫名其妙出现了没有修改到的数据</p><p>MySQL 的 InnoDB 默认是 RR，为什么可以解决幻读？</p><p>因为默认开启了间隙锁，这样就防止了两次 select 之间，有另外的事务进行增删操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h1&gt;&lt;p&gt;事务，首先要了解 ACID&lt;/p&gt;
&lt;h2 id=&quot;A-原子性&quot;&gt;&lt;a href=&quot;#A-原子性&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁</title>
    <link href="https://linweiyuan.github.io/2021/06/25/MySQL%E9%94%81.html"/>
    <id>https://linweiyuan.github.io/2021/06/25/MySQL%E9%94%81.html</id>
    <published>2021-06-25T15:03:53.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>update 的时候行级锁，如果未 commit，另一个事务会尝试拿锁，超时则报错</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p>索引失效，行锁会升级为表锁，比如 update 的时候有 or，这样就算在一个事务中 update id &#x3D; 1 or id &#x3D; 2，另一个事务要 update id &#x3D; 3，也会阻塞，一旦发生表锁，并发度是比较低的，所以要避免索引失效</p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>一般发生在范围查询里面，把整个范围加锁，如果要在这个范围内插入新数据，也会阻塞，性能影响也是比较大的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到一些锁相关数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;行锁&quot;&gt;&lt;a href=&quot;#行锁&quot; class=&quot;headerlink&quot; title=&quot;行锁&quot;&gt;&lt;/a&gt;行锁&lt;/h1&gt;&lt;p&gt;update 的时候行级锁，如果未 commit，另一个事务会尝试拿锁，超时则报错&lt;/p&gt;
&lt;h1 id=&quot;表锁&quot;&gt;&lt;a href=&quot;#表锁</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引相关</title>
    <link href="https://linweiyuan.github.io/2021/06/18/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3.html"/>
    <id>https://linweiyuan.github.io/2021/06/18/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3.html</id>
    <published>2021-06-18T14:04:59.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><p>要了解索引，首先要了解 MySQL 的 B+树数据结构</p><p>为什么是 B+ 树？</p><p>和 B 树相比，多了箭头，称为叶子节点，其实就是一个单向链表，进行了排序，解决了回旋查找的问题</p><p>非叶子节点只存 key，叶子节点既存 key 又存 value（数据地址）</p><hr><h1 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h1><p>聚簇索引就是把数据和索引放在一个文件里面，叶子节点保存行数据，数据按照索引的顺序来进行存储，也就是说索引项的顺序和表中记录的物理顺序一致，InnoDB 中，在聚簇索引之上创建的索引称为辅助索引，比如复合索引，前缀索引，唯一索引等</p><ul><li>聚簇索引是一个概念，默认实现是是主键</li><li>如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替</li><li>如果没有唯一非空的索引，InnoDB 会在内部生成一个名为 GEN_CLUST_INDEX 的隐式的聚簇索引</li></ul><p>在数据（索引）文件中，非叶子节点保存的是主键，叶子节点保存的是真实数据，因为只有一个文件</p><p>辅助索引中，非叶子节点保存的是字段的值（排序），叶子节点保存的是该条记录的主键 ID 值</p><p>所以，如果是主键索引，只需查一次，一定程度上会比 MyISAM 快，但是辅助索引要查到 ID 再到主键索引查数据，要查两次，一定程度上会比 MyISAN 慢</p><p>为什么不能 select *，要尽可能使用覆盖索引？</p><p>如果是查单个字段，在这个字段上建立了索引，只需查一次就能拿到该字段数据，如果 select *，那就要查到 ID，再根据 ID 来查询全部，查两次</p><h1 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h1><p>将数据和索引分开存储，表数据存储顺序和索引顺序无关</p><p>在索引文件中，非叶子节点保存的是主键，叶子节点保存的是主键和数据在数据文件中的地址</p><hr><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><ul><li>尽量在只需要查询到的字段上加索引（where）</li><li>基数小的字段不加索引（出现重复的越多越不加， 唯一才能查询快）</li><li>如果字符串太长但是前面不重复， 使用短索引（根据前面几个字符就能确定唯一）</li><li>不要过度使用索引， 占用磁盘空间， 更新操作影响性能</li><li>建立索引的字段， 尽量不要有 null（not null + 默认值）</li><li>like 查询中前导模糊查询不能命中索引（like ‘%a%’ 不走索引，like ‘a%’ 走）</li><li>如果字段是字符串， 查询时用整形， 索引失效</li><li>复合索引（最左原则， 查询条件如果不包含第一个字段， 索引失效）</li><li>sql 查询 cpu 开销：or &gt; in &gt; union</li><li>or 查询如果前面的条件有索引， 后面没有， 索引失效</li><li>否定查询索引失效（!&#x3D;， &lt;&gt;， not in， not exists， not like）</li><li>用 explain 来分析 sql 性能</li></ul><hr><h1 id="索引失效原理"><a href="#索引失效原理" class="headerlink" title="索引失效原理"></a>索引失效原理</h1><p>针对联合索引的情况，数据保存的时候，是有顺序的，两个字段 a 和 b，先按 a 排序，在 a 相同的情况下按 b 排序，所以如果直接查 b，是无序的，因此不走索引，要全表扫描，范围查找，模糊查询也是这个道理</p><hr><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ul><li>最左前缀法则：如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右（和 B+ 树的数据结构有关），比如 abc，在这种情况下：<ul><li>abc：有效</li><li>ac：a 有效 c 无效</li><li>bc：bc 都无效</li><li>c：无效</li></ul></li><li>不要对索引进行如下处理：<ul><li>计算：如加减乘除，不等，is null， is not null， or</li><li>函数：如 sum()， round()等</li><li>类型转换：如 id &#x3D; ‘1’，本来是数字写成了字符串</li></ul></li><li>索引不要放在范围查找的右边</li><li>减少 select * 的使用</li><li>like 模糊查询：只留右边的百分号，那是否两个百分号没得优化呢，也不是，可以使用覆盖索引，所谓覆盖索引就是 select 查询的字段和 where 里的字段是一致的，也会走索引</li><li>order by 优化，避免出现 Using filesort 文件内排序，所谓 filesort，就是说它没有按照索引本身来进行排序，而是在外面开辟了一块内存，把数据复制进去进行排序，这样内存就会被多占用一份空间，而内存是比较宝贵的资源，比较影响性能</li></ul><p>其实也可以考虑不在 MySQL 里排序，而在代码里进行排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B+ 树&quot;&gt;&lt;/a&gt;B+ 树&lt;/h1&gt;&lt;p&gt;要了解索引，首先要了解 MySQL 的 B+树数据结构&lt;/p&gt;
&lt;p&gt;为什么是 B+ 树？&lt;/p&gt;
&lt;p&gt;和 B 树相比，多了箭</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="https://linweiyuan.github.io/2021/05/20/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"/>
    <id>https://linweiyuan.github.io/2021/05/20/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html</id>
    <published>2021-05-20T14:03:11.000Z</published>
    <updated>2022-09-27T02:07:30.582Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB 和 MyISAM 的区别</p><ul><li>InnoDB 支持事务，MyISAM 不支持，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一</li><li>InnoDB 支持外键，MyISAM 不支持，对一个包含外键的 InnoDB 表转为 MyISAM 会失败</li><li>InnoDB 是聚集索引（聚簇索引），MyISAM 是非聚集索引</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，这也是默认存储引擎改变的重要原因之一</li><li>MyISAM 在硬盘上存储为三个文件<ul><li>.frm：表的定义</li><li>.myd：数据文件</li><li>.myi：索引文件</li></ul></li><li>InnoDB 是两个文件（没有专门保存数据的文件）<ul><li>.frm：表的定义</li><li>.ibd：数据和索引文件，数据以主键进行聚集存储，把真正的数据保存在叶子节点中</li></ul></li><li>全文索引都支持</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB 和 MyISAM 的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB 支持事务，MyISAM 不支持，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一&lt;/li&gt;
&lt;li&gt;InnoDB 支持外键，MyISAM 不支持，对一个包含外</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
