<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林伟源的技术博客</title>
  
  
  <link href="https://linweiyuan.github.io/atom.xml" rel="self"/>
  
  <link href="https://linweiyuan.github.io/"/>
  <updated>2022-09-24T18:39:03.775Z</updated>
  <id>https://linweiyuan.github.io/</id>
  
  <author>
    <name>林伟源</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ingress配置pgAdmin需要注意的问题</title>
    <link href="https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2022-09-23T17:32:34.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<p>当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去</p><p>但是基于 K8s 环境下部署的时候，需要稍微注意一点地方</p><h1 id="K8s-集群准备"><a href="#K8s-集群准备" class="headerlink" title="K8s 集群准备"></a>K8s 集群准备</h1><p>K8s 的搭建方式多种多样，比如 k3d、kubeadm、kind 等，由于多年之前有裸装 Oracle 把系统搞烂的经历，对于一些软件的安装，我这边是比较谨慎的。况且后面接触了容器，能在里面跑就里面跑，什么两倍读写的问题不考虑，所以我使用的是 <code>kind</code> 来搭建集群</p><p>为了服务在容器外能访问，kind 创建 K8s 集群的时候还需要一些额外的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kind.x-k8s.io/v1alpha4</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">apiServerAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">apiServerPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">control-plane</span></span><br><span class="line">    <span class="attr">kubeadmConfigPatches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        kind: InitConfiguration</span></span><br><span class="line"><span class="string">        nodeRegistration:</span></span><br><span class="line"><span class="string">          kubeletExtraArgs:</span></span><br><span class="line"><span class="string">            node-labels: &quot;ingress-ready=true&quot;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">extraPortMappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">hostPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h1 id="Ingress-Controller-准备"><a href="#Ingress-Controller-准备" class="headerlink" title="Ingress Controller 准备"></a>Ingress Controller 准备</h1><p>K8s 暴露服务的方式也多种多样，比如 NodePort、LoadBalancer、Ingress。由于 kind 的特殊性，整个 K8s 集群都跑在容器中，所以就算 NodePort 也是容器里的端口，所以这次主要讨论 Ingress，使用的是 <code>Nginx</code></p><p>使用 Ingress，首先需要在集群中安装一个 Ingress Controller，然后通过 Ingress 来进行一些配置，当 apply 的时候，Ingress Controller 会自动更新 nginx.conf 并进行 reload</p><p>如果之前配置过 Nginx，其实类比起来是很像的，一个 Ingress Controller 相当于一个 Nginx，一个 Ingress 则好比 Nginx 的配置文件</p><p>当 Ingress Controller 准备好后，会以 NodePort 的方式暴露 80 和 443 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.30.54    &lt;none&gt;        80:30860/TCP，443:31875/TCP   3d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pgAdmin-准备"><a href="#pgAdmin-准备" class="headerlink" title="pgAdmin 准备"></a>pgAdmin 准备</h1><p>为了简单起见，使用 <code>helm</code> 来安装 pgAdmin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pgadmin runix/pgadmin4 --<span class="built_in">set</span> env.email=root@linweiyuan.com --<span class="built_in">set</span> env.password=toor</span><br></pre></td></tr></table></figure><h1 id="Ingress-准备"><a href="#Ingress-准备" class="headerlink" title="Ingress 准备"></a>Ingress 准备</h1><p>配置好 Ingress 规则，因为想做到访问不同的 path 路由到不同的服务，所以这里用 &#x2F;pgAdmin 来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>但是此时访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a> 的时候，会返回 404</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not Found The requested URL was not found on the server. If you entered the URL</span><br><span class="line">manually please check your spelling and try again.</span><br></pre></td></tr></table></figure><h1 id="pgAdmin-访问解决"><a href="#pgAdmin-访问解决" class="headerlink" title="pgAdmin 访问解决"></a>pgAdmin 访问解决</h1><p>查看<a href="https://www.pgadmin.org/docs/pgadmin4/latest/container_deployment.html#http-via-nginx">官方文档</a>，会发现这么一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If you wish to host pgAdmin under a subdirectory rather than on the root of the server, you must specify the location and set the X-Script-Name header which tells the pgAdmin container how to rewrite paths</span><br></pre></td></tr></table></figure><p>就是说 Nginx 的配置里要加 <code>X-Script-Name</code>，但是在 K8s 里要怎么加？</p><p>前面提过，其实无非是修改 Ingress 的配置，此时如果进入 Ingress Controller 的 pod 中查看配置文件，会发现当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ hostname</span><br><span class="line">ingress-nginx-controller-65b4b4df7d-rhd2k</span><br><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   415location = /pgAdmin &#123;</span><br><span class="line">   421<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br></pre></td></tr></table></figure><p>而根据 pgAdmin 官方文档的指引，需要把配置加到 location 下，回头查看 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md#configuration-snippet">K8s 官方文档</a>，发现其实是配置 <code>nginx.ingress.kubernetes.io/configuration-snippet</code></p><p>因此配置文件进行修改，完整配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pgadmin-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/configuration-snippet:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      proxy_set_header X-Script-Name /pgAdmin;</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&quot;/pgAdmin&quot;</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pgadmin-pgadmin4</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>再 apply</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kaf pgadmin-ingress.yaml</span><br><span class="line">ingress.networking.k8s.io/pgadmin-ingress configured</span><br></pre></td></tr></table></figure><p>再查看 nginx.conf，已经生效了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1$ <span class="built_in">cat</span> -n nginx.conf | grep pgAdmin</span><br><span class="line">   297location /pgAdmin/ &#123;</span><br><span class="line">   303<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   409proxy_set_header X-Script-Name /pgAdmin;</span><br><span class="line">   417location = /pgAdmin &#123;</span><br><span class="line">   423<span class="built_in">set</span> <span class="variable">$location_path</span>  <span class="string">&quot;/pgAdmin&quot;</span>;</span><br><span class="line">   529proxy_set_header X-Script-Name /pgAdmin;</span><br></pre></td></tr></table></figure><p>此时再访问 <a href="http://localhost/pgAdmin">http://localhost/pgAdmin</a></p><p>会自动跳转 <a href="http://localhost/pgAdmin/login?next=/pgAdmin/">http://localhost/pgAdmin/login?next=%2FpgAdmin%2F</a></p><p>用上面 helm 设置的用户名和密码即可登录进去，问题解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去&lt;/p&gt;
&lt;p&gt;但是基于 K8s 环境下部署的时候，需要稍微注意一点地方&lt;/p&gt;
&lt;h1 id=&quot;K8s-集群准备&quot;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="pgAdmin" scheme="https://linweiyuan.github.io/tags/pgAdmin/"/>
    
    <category term="Ingress" scheme="https://linweiyuan.github.io/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>利用 Github Actions 实现代码提交自动部署更新 Kubernetes</title>
    <link href="https://linweiyuan.github.io/2022/09/13/%E5%88%A9%E7%94%A8GithubActions%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9B%B4%E6%96%B0Kubernetes.html"/>
    <id>https://linweiyuan.github.io/2022/09/13/%E5%88%A9%E7%94%A8GithubActions%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9B%B4%E6%96%B0Kubernetes.html</id>
    <published>2022-09-13T04:31:35.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub: <a href="https://github.com/linweiyuan/github-actions-tests">https://github.com/linweiyuan/github-actions-tests</a></p><p>可以换掉大部分 Jenkins + webhooks 的场景</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=772888317&bvid=BV1W14y1e7md&cid=831313464&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/linweiyuan/github-actions-tests&quot;&gt;https://github.com/linweiyuan/github-actions-tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以换掉大部</summary>
      
    
    
    
    <category term="Github Actions" scheme="https://linweiyuan.github.io/categories/Github-Actions/"/>
    
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="Golang" scheme="https://linweiyuan.github.io/tags/Golang/"/>
    
    <category term="Github Actions" scheme="https://linweiyuan.github.io/tags/Github-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现 i3bar 显示歌词</title>
    <link href="https://linweiyuan.github.io/2022/09/06/Go%E5%AE%9E%E7%8E%B0i3bar%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D.html"/>
    <id>https://linweiyuan.github.io/2022/09/06/Go%E5%AE%9E%E7%8E%B0i3bar%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D.html</id>
    <published>2022-09-06T04:31:35.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-Go-实现的-i3bar-歌词显示程序"><a href="#基于-Go-实现的-i3bar-歌词显示程序" class="headerlink" title="基于 Go 实现的 i3bar 歌词显示程序"></a>基于 Go 实现的 i3bar 歌词显示程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/linweiyuan/goi3barlyric.git</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar &#123;</span><br><span class="line">    status_command goi3barlyric</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制较多，实验性质</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=472777097&bvid=BV1bK411f7Vr&cid=825016487&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-Go-实现的-i3bar-歌词显示程序&quot;&gt;&lt;a href=&quot;#基于-Go-实现的-i3bar-歌词显示程序&quot; class=&quot;headerlink&quot; title=&quot;基于 Go 实现的 i3bar 歌词显示程序&quot;&gt;&lt;/a&gt;基于 Go 实现的 i3bar 歌词显示</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Golang" scheme="https://linweiyuan.github.io/tags/Golang/"/>
    
    <category term="i3" scheme="https://linweiyuan.github.io/tags/i3/"/>
    
    <category term="i3bar" scheme="https://linweiyuan.github.io/tags/i3bar/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用服务</title>
    <link href="https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html</id>
    <published>2022-07-26T18:42:48.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<p>整理了下常用的 <code>Docker</code> 服务： <a href="https://github.com/linweiyuan/docker-services">https://github.com/linweiyuan/docker-services</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理了下常用的 &lt;code&gt;Docker&lt;/code&gt; 服务： &lt;a href=&quot;https://github.com/linweiyuan/docker-services&quot;&gt;https://github.com/linweiyuan/docker-services&lt;/a&gt;</summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 使用国内镜像源时遇到的坑</title>
    <link href="https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
    <id>https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</id>
    <published>2022-07-25T02:50:47.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<p>详见：<a href="https://github.com/ustclug/discussions/issues/396">https://github.com/ustclug/discussions/issues/396</a></p><p>“故从 2020 年 4 月起，从科大校外对 Docker Hub 镜像缓存的访问会被 302 重定向至其他国内 Docker Hub 镜像源”</p><p>可以看到是重定向到阿里云</p><p><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a> -&gt; <a href="https://ustc-edu-cn.mirror.aliyuncs.com/">https://ustc-edu-cn.mirror.aliyuncs.com</a></p><p>但是校外访问这个仓库已经是旧的了</p><p>替代品</p><ul><li>直连</li><li>阿里云（广州或杭州，或自己账号）：<a href="https://registry.cn-guangzhou.aliyuncs.com/">https://registry.cn-guangzhou.aliyuncs.com</a></li><li>网易（容易连着连着自动断开）：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详见：&lt;a href=&quot;https://github.com/ustclug/discussions/issues/396&quot;&gt;https://github.com/ustclug/discussions/issues/396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;“故从 2020 年 4 </summary>
      
    
    
    
    <category term="容器技术" scheme="https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://linweiyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>30分钟从0到1搭建一个最基础的Rancher</title>
    <link href="https://linweiyuan.github.io/2022/06/04/30%E5%88%86%E9%92%9F%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84Rancher.html"/>
    <id>https://linweiyuan.github.io/2022/06/04/30%E5%88%86%E9%92%9F%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84Rancher.html</id>
    <published>2022-06-04T04:31:35.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<p>宿主机 Arch Linux，cgroup v2, 安装会报错，解决方案 -&gt; systemd.unified_cgroup_hierarchy&#x3D;0</p><p>简单起见，基于虚拟机 CentOS 7.9，一主两从<br>rancher 管理机：192.168.31.240<br>k8s 一主节点：192.168.31.250<br>k8s 两从节点：192.168.31.251, 192.168.31.252</p><p>docker 私有仓库： distribution&#x2F;registry</p><p>内网 dns：dnsmasq</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=560999944&bvid=BV1Fe4y1B7Bf&cid=842560164&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;宿主机 Arch Linux，cgroup v2, 安装会报错，解决方案 -&amp;gt; systemd.unified_cgroup_hierarchy&amp;#x3D;0&lt;/p&gt;
&lt;p&gt;简单起见，基于虚拟机 CentOS 7.9，一主两从&lt;br&gt;rancher 管理机：192.1</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Arch Linux" scheme="https://linweiyuan.github.io/tags/Arch-Linux/"/>
    
    <category term="Rancher" scheme="https://linweiyuan.github.io/tags/Rancher/"/>
    
    <category term="Kubernetes" scheme="https://linweiyuan.github.io/tags/Kubernetes/"/>
    
    <category term="CentOS" scheme="https://linweiyuan.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux简易安装脚本（i3, kde, deepin）</title>
    <link href="https://linweiyuan.github.io/2022/04/08/Arch-Linux%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88i3-kde-deepin%EF%BC%89.html"/>
    <id>https://linweiyuan.github.io/2022/04/08/Arch-Linux%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88i3-kde-deepin%EF%BC%89.html</id>
    <published>2022-04-08T04:19:56.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<p>脚本：<a href="https://github.com/linweiyuan/archlinux-install-script">https://github.com/linweiyuan/archlinux-install-script</a><br>todo: 异常判断，选项改 whiptail</p><p>包缓存：flexo</p><p>内网 dns：dnsmasq</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=603487924&bvid=BV1VB4y177EU&cid=842532702&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;脚本：&lt;a href=&quot;https://github.com/linweiyuan/archlinux-install-script&quot;&gt;https://github.com/linweiyuan/archlinux-install-script&lt;/a&gt;&lt;br&gt;todo: 异</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Arch Linux" scheme="https://linweiyuan.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK18的UTF-8</title>
    <link href="https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html"/>
    <id>https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html</id>
    <published>2022-03-24T07:07:34.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JEP-400-UTF-8-by-Default"><a href="#JEP-400-UTF-8-by-Default" class="headerlink" title="JEP 400: UTF-8 by Default"></a>JEP 400: UTF-8 by Default</h1><p>JDK18 里有一项改进叫：<a href="https://openjdk.org/jeps/400">JEP 400: UTF-8 by Default</a></p><p>其实是将默认字符集改为 UTF-8，只是 Charset.defaultCharset() 返回 UTF-8，在这之前的 JDK 版本中，返回的字符集根据操作系统的不同会不一样，有可能会导致乱码，可以看到这个方法的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br><span class="line"></span><br><span class="line">The <span class="keyword">default</span> charset is UTF-<span class="number">8</span>, unless changed in an implementation specific manner.</span><br></pre></td></tr></table></figure><p>之前的版本只有这一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns the <span class="keyword">default</span> charset of <span class="built_in">this</span> Java virtual machine.</span><br></pre></td></tr></table></figure><p>所以并不是改了 String 的实现</p><h1 id="JEP-254-Compact-Strings"><a href="#JEP-254-Compact-Strings" class="headerlink" title="JEP 254: Compact Strings"></a>JEP 254: Compact Strings</h1><p>Java 中的 String 默认采用 UTF-16 字符集，这其实是历史的包袱，为了要支持新版本的 Unicode，又要保证向后兼容，因为谁也想不到计算机的发展是如此迅猛，当时是足够用了</p><p>如今用了 UTF-16，可以存大部分辅助字符（Emoji 等）了，但是对于西方国家，日常的简单字母，有点浪费</p><p>因此 JDK9 进行了改动，将底层 char[] 改为 byte[]，并且在原有基础上加入了 Latin-1（ISO-8859-1）字符集，详细可以看这个 JEP：<a href="https://openjdk.org/jeps/254">JEP 254: Compact Strings</a></p><p>String(UTF-16 + Latin-1)，其中内部多了个字段 coder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br></pre></td></tr></table></figure><p>当无法用 Latin-1 表示的时候，才使用 UTF-16，减少了内存的浪费</p><p>所以 JEP 400 和 String 本身的实现关系不大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JEP-400-UTF-8-by-Default&quot;&gt;&lt;a href=&quot;#JEP-400-UTF-8-by-Default&quot; class=&quot;headerlink&quot; title=&quot;JEP 400: UTF-8 by Default&quot;&gt;&lt;/a&gt;JEP 400: UTF-</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="JDK18" scheme="https://linweiyuan.github.io/tags/JDK18/"/>
    
  </entry>
  
  <entry>
    <title>线程相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/10/24/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/10/24/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-10-24T15:13:13.000Z</published>
    <updated>2022-09-24T18:39:03.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>初始状态 new</li><li>可运行&#x2F;运行状态 runnable</li><li>休眠状态 blocked waiting timed_waiting</li><li>终止状态 terminated</li></ul><h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><ul><li>创建：new</li><li>就绪：start()，可运行，等待获取 CPU 的使用权</li><li>运行：执行</li><li>阻塞：放弃 CPU 使用权，sleep，wait（sleep 是 Thread 的，wait 是 Object 的）</li><li>死亡：执行完或异常退出</li></ul><h1 id="线程的-run-和-start-的区别"><a href="#线程的-run-和-start-的区别" class="headerlink" title="线程的 run() 和 start() 的区别"></a>线程的 run() 和 start() 的区别</h1><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，run() 可以重复调用，而 start() 只能调用一次，如果直接调用线程的 run() 方法，相当于执行一个普通方法，不在整个线程的生命周期中</p><h1 id="如何停止一个线程"><a href="#如何停止一个线程" class="headerlink" title="如何停止一个线程"></a>如何停止一个线程</h1><ul><li>使用 flag</li><li>stop()</li><li>interrupt()</li></ul><h1 id="sleep-wait-join-yield"><a href="#sleep-wait-join-yield" class="headerlink" title="sleep(), wait(), join(), yield()"></a>sleep(), wait(), join(), yield()</h1><ul><li>sleep: Thread 类的静态方法，不依赖于 synchronized，一般用于当前线程休眠，会释放锁</li><li>wait: Object 类的普通方法，依赖于 synchronized，一般用于多线程之间的通信，不会释放锁，要使用 notify() 或者 notifyAll() 唤醒</li><li>yield: 执行后线程进入就绪状态，马上释放了 CPU 的执行权，但是保留了 CPU 的执行资格，可能在下次调度的时候再次获得执行权</li><li>join: 执行后线程进入阻塞状态，让 join 的线程先执行完或中断</li></ul><h1 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify() 和 notifyAll() 的区别"></a>notify() 和 notifyAll() 的区别</h1><p>notify() 随机唤醒一个线程，notifyAll() 唤醒所有的线程，当 notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，不成功则留在锁池等待锁释放后再次参与竞争</p><h1 id="实现多线程的几种方式"><a href="#实现多线程的几种方式" class="headerlink" title="实现多线程的几种方式"></a>实现多线程的几种方式</h1><ul><li>继承 Thread 类（实际上 Thread implements Runnable）</li><li>实现 Runnable 接口</li><li>实现 Callable 接口（通过 FutureTask 包装器来创建）</li><li>通过线程池创建线程，使用线程池接口 ExecutorService 结合 Callable，Future 实现有返回值的多线程</li></ul><p>runnable 有两个弊端（Callable 和 Runnable 的最大区别就是 Callable 可以有返回值）：</p><ul><li>不能获取返回结果</li><li>不能抛出异常</li></ul><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程是运行在后台的一种特殊进程，为所有非守护线程提供服务，比如 GC 线程就是特殊的守护线程</p><p>用法注意：thread.setDaemon(true) 必须在 thread.start() 之前设置，否则抛出异常 IllegalThreadStateException，因为不能把正在运行的常规线程设置为守护线程</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 不是多线程同步机制中的一种，而是一种解决思路，它解决的是多线程下成员变量的安全问题，不是共享变量的安全问题</p><p>线程同步机制是多个线程共享一个变量，而 ThreadLocal 是每个线程创建一个自己的单独变量副本，所以每个线程都可以独立地改变自己的变量副本，而不会影响到其他线程的变量副本</p><p>ThreadLocal 内部有一个非常重要的内部类：<code>ThreadLocalMap</code>，是真正实现线程隔离机制的关键，ThreadLocalMap 内部结构类似于 Map，由键值对 key 和 value 组成一个 entry，key 为 ThreadLocal 本身，value 是对应的线程变量副本（首先是 Thread，Thread 里面有 ThreadLocal.ThreadLocalMap，Map 的话存储的是 Entry 集合，每一个 Entry 的 key 为 ThreadLocal，value 为具体的值）</p><p>有两点需要注意</p><ul><li>ThreadLocal 本身不存储值，它只是提供一个查找到值的 key</li><li>ThreadLocal 包含在 Thread 中，不是 Thread 包含在 ThreadLocal 中</li></ul><p>ThreadLocalMap 和 HashMap 的功能类似，但是实现上却有很大的不同：</p><ul><li>HashMap 的数据结构是数组 + 链表</li><li>ThreadLocalMap 的数据结构仅仅是数组</li><li>HashMap 是通过链地址法来解决哈希冲突，ThreadLocalMap 是通过开放地址法来解决哈希冲突（链地址：数组加链表，开放地址：寻找空的位置）</li><li>HashMap 里面的 Entry 内部类的引用都是强引用，ThreadLocalMap 里面的 Entry 内部类中的 key 是弱引用，value 是强引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt;</span><br></pre></td></tr></table></figure><p>从源码可以看出 ThreadLocal.ThreadLocalMap.Entry 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用，也就是说，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候 key 会被清理掉，而 value 不会被清理，这样一来，ThreadLocalMap 中就会出现 key 的 null 的 Entry，假如不做任何措施的话，value 永远无法被 GC，这个时候就可能产生内存泄漏</p><p>如何避免内存泄漏？</p><p>当一个变量不用的时候，要调用 remove() 删除掉（内部调用了 expungeStaleEntry()，将 value 设为 null，这样下一次垃圾回收时就会被彻底回收掉）</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 全称 Compare And Swap，比较并交换，是一条 CPU 的并发原语</p><p>原语的执行必须是连续的，在执行的过程中不允许被中断，因此不会造成数据不一致的问题，具有原子性。CAS 是一种重要的同步思想，判断内存中的值是否和预期的值一样，如果是，则将内存中的值更新为新值，否则会不断重试，直到一致为止</p><p>ABA 问题</p><p>比较并交换的循环，存在一个时间差，而这个时间差可能带来意想不到的问题</p><p>比如两个线程 A 和 B</p><ul><li>一开始都从主内存中拷贝了原值为 1</li><li>线程 A 执拿到值为 1 然后挂起</li><li>线程 B 修改值为 2，执行完毕</li><li>线程 B 觉得修改错误，把值重新设置为 1，</li><li>线程 A 被唤醒，比较发现内存中的值和预期的值一样，修改成功（但是不知道这个值已经被 B 修改过了）</li></ul><p>尽管线程 A CAS 操作成功，但不代表没有问题，有的需求，只注重头和尾，只要首尾一致，就接受，但是有的需求，还看重过程，中间不能发生任何修改，这就引出了 AtomicStampedReference 原子引用</p><p>AtomicStampedReference 内部维护了一个版本号 <code>stamp</code>，在进行 CAS 操作的时候，不仅要比较当前值，还要比较版本号，只有两者都相等，才执行更新操作（有点类似乐观锁）</p><p>任何技术都不是完美的，CAS 也有自己的缺点，CAS 实际上是一种自旋锁</p><ul><li>一直循环，开销比较大</li><li>只能保证一个变量的原子操作，多个变量依然要加锁</li><li>引出了 ABA 问题（AtomicStampedReference 可解决）</li></ul><p>CAS 的使用场景适合在一些并发量不高，线程竞争较少的情况，但是一旦线程冲突严重的情况，循环时间太长，会给 CPU 带来很大的开销</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><p>JDK 中提供了创建线程池的类，<code>Executors</code>，但是一般不推荐</p><p>Executors 类只是个静态工厂，提供创建线程池的几个静态方法（内部屏蔽了线程池参数配置细节），而真正的线程池类是 <code>ThreadPoolExecutor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize，</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize，</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime，</span></span><br><span class="line"><span class="params">  TimeUnit unit，</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue，</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory，</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>核心参数：</p><ul><li>corePoolSize：核心线程数。如果等于 0，则任务执行完毕后，没有任务请求进入时，销毁线程池中的线程。如果大于 0，即使本地任务执行完毕，核心线程也不会被销毁。设置得过大会浪费系统资源，设置过小会导致线程频繁创建</li><li>maximumPoolSize：最大线程数。必须大于等于 1，且大于等于 corePoolSize。如果与 corePoolSize 相等，则线程池大小固定。如果大于 corePoolSize，则最多创建 maximumPoolSize 个线程执行任务</li><li>keepAliveTime：线程空闲时间。线程池中线程空闲时间达到 keepAliveTime 值时，线程会被销毁，直到剩下 corePoolSize 个线程为止。默认情况下，线程池的最大线程数大于 corePoolSize 时，keepAliveTime 才会起作用。如果 allowCoreThreadTimeOut 被设置为 true，即使线程池的最大线程数等于 corePoolSize，keepAliveTime 也会起作用（回收超时的核心线程）</li><li>unit：TimeUnit 表示时间单位</li><li>workQueue：缓存队列。当请求线程数大于 corePoolSize 时，线程进入 BlockingQueue 阻塞队列</li><li>threadFactory：线程工厂。用来生产一组相同任务的线程。主要用于设置生成的线程名词前缀，是否为守护线程以及线程的优先级等。设置有意义的名称前缀可以很快知道线程是由哪个线程工厂创建的，方便调试</li><li>handler：执行拒绝策略对象。当任务数达到缓存上限时（即超过 workQueue 参数能存储的任务数），执行拒绝策略，相当于限流保护</li></ul><p>上面复杂概念的简洁描述：</p><ul><li>如果线程池当前状态不是 running，直接拒绝</li><li>如果 worker &lt; pool，创建新线程</li><li>如果 worker &gt;&#x3D; pool，queue 未满，将任务添加到 queue</li><li>如果 pool &lt;&#x3D; worker &lt; max，并且 queue 已满，开启新线程</li><li>如果 worker &gt; max，并且 queue 已满，拒绝策略（默认直接抛异常）</li></ul><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><ul><li>FixedThreadPool：固定长度的线程池，核心线程数等于最大线程数，不存在空闲线程，keepAliveTime 为 0，可以控制线程的最大并发数，超出的线程会放到队列中</li><li>SingleThreadExecutor：单线程线程池，核心线程数和最大线程数都是 1，它只会用唯一的线程来执行任务，相当于串行执行，超出的线程会放到队列中</li><li>CachedThreadPool：可缓存的线程池，核心线程数为 0，最大线程数为 Integer.MAX_VALUE，如果数据过多，它会不断地创建新的线程，存在 OOM 风险，keepAliveTime 为 60，工作线程处于空闲状态超过 keepAliveTime 会回收线程</li><li>WorkStealingPool：JDK 1.8 引入，核心是工作窃取，没怎么见人用过</li><li>ScheduledThreadPool：用于定时执行任务的线程池</li></ul><p>禁止直接使用 Executors 创建线程池的原因（除 Executors.newWorkStealingPool 方法之外，其他方法都有 OOM 风险）：</p><ul><li>Executors.newCachedThreadPool 和 Executors.newScheduledThreadPool 两个方法最大线程数为 Integer.MAX_VALUE，如果线程数太多，会有 OOM 的风险</li><li>Executors.newSingleThreadPool 和 Executors.newFixedThreadPool 两个方法的 workQueue 参数为 LinkedBlockingQueue，容量为 Integer.MAX_VALUE，如果瞬间请求过大，导致队列中任务过多，会有 OOM 风险</li></ul><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><p>ThreadPoolExecutor 提供了四个公开的静态内部类：</p><ul><li>AbortPolicy：默认，丢弃任务并抛出 RejectedExecutionException</li><li>DiscardPolicy：丢弃任务，但是不抛出异常（不推荐）</li><li>DiscardOldestPolicy：丢弃队列中等待最久的任务，然后把当前的新任务加入到队列中</li><li>CallerRunsPolicy：调用任务的 run() 方法绕过线程池直接执行</li></ul><h2 id="如何自定义拒绝策略"><a href="#如何自定义拒绝策略" class="headerlink" title="如何自定义拒绝策略"></a>如何自定义拒绝策略</h2><p>实现 RejectedExecutionHandler 接口或继承已有策略，重写 rejectedExecution() 方法</p><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><p>线程池，数据库连接池，HTTP 连接池等都属于池化技术，主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务），每个线程池还维护一些基本统计信息例如已完成任务的数量</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高相应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;初始状态 new&lt;/li&gt;
&lt;li&gt;可运行&amp;#x2F;运行状态 runnable&lt;/li&gt;
&lt;li&gt;休眠状态 b</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="Thread" scheme="https://linweiyuan.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>JVM相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/10/01/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/10/01/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-10-01T13:53:27.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h1><p>程序计数器里面存放的是下一条 JVM 指令代码的执行地址，概念上有点类似数据库结果集遍历时的游标，不断指向下一条，物理上是通过寄存器实现的，寄存区在 CPU 上是非常快的单元</p><p>在 JVM 的规范中，每条线程都有自己的程序计数器，所以程序计数器是线程私有的，因为当发生线程切换的时候，需要知道切换回来后下一步应该执行什么操作，如果不是线程私有则会造成混乱</p><p>程序计数器是 JVM 中唯一不会存在 OOM 的区域，这一点是 JVM 规范上要求的</p><hr><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>说虚拟机栈之前先说栈，栈的特点就是先进后出或后进先出</p><p>虚拟机栈是线程运行时需要的内存空间，线程运行的目的是为了执行代码，代码由一个个方法组成，当线程运行的时候，每个方法需要的内存空间就是栈帧（参数，局部变量，返回地址），每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，调用方法时入栈，执行完出栈，每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（栈顶部），栈是有一定的深度的，当发生递归死循环时，一直有方法入栈但不出栈，导致栈溢出，抛出 <code>java.lang.StackOverflowError</code></p><p>IDEA debug 时左下角的 Frame 就是栈帧，比较直观，从上到下，右边还可以看到栈内的局部变量值</p><h2 id="垃圾回收是否涉及栈内存"><a href="#垃圾回收是否涉及栈内存" class="headerlink" title="垃圾回收是否涉及栈内存"></a>垃圾回收是否涉及栈内存</h2><p>不会</p><p>栈内存随着出栈就释放掉，垃圾回收主要用来回收堆内存</p><h2 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h2><p>不是</p><p>-Xss size（比如-Xss1m，没有等号）</p><p>Windows 下取决于虚拟内存的设置，其他主流操作系统上默认为 1024KB（1MB）</p><p>物理内存的大小是固定的，栈内存分配设置得越大，占用越多内存，由于栈是线程私有的，所以线程占用的内存就会变大，那么操作系统可以创建的总线程数就会变小</p><p>比如操作系统 10M 内存（只是举例），本来一个线程默认占用 1M 内存，那么可以创建 10 个线程，但设置-Xss2m 后，只能创建 5 个线程了</p><p>-Xss 设置得大，只会增加方法递归调用的次数，一般不会提升性能，就是不容易爆栈，但死循环递归该爆还得爆</p><h2 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全"></a>方法内的局部变量是否线程安全</h2><p>是</p><p>每个线程都有私有的栈帧，里面会有各自独立的变量，互不干扰。线程安全问题出现在共享变量上，如果方法内局部变量没有逃离方法的作用范围，那么这个局部变量就是线程安全的</p><h2 id="线上诊断方法"><a href="#线上诊断方法" class="headerlink" title="线上诊断方法"></a>线上诊断方法</h2><p>通常都是十八般武艺配合着来用，包括但不限于：</p><ul><li>top 命令，查看 %CPU，配合 grep java</li><li>ps H -eo pid,tid,%cpu(小写 cpu) | grep 进程号</li><li>jstack 进程 id，会列出所有线程，有线程号 nid（16 进制），printf ‘%x’ 10 进制 id</li><li>jstack 查看是否出现死锁</li></ul><hr><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>native 地方法运行时所需要的空间，其他的每什么好说的了，不懂</p><hr><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>通过 new 关键字创建的对象都会使用堆内存<br>堆里面的对象是线程共享的，所以一般都需要考虑线程安全的问题，堆有垃圾回收机制，并且会发生内存溢出 <code>java.lang.OutOfMemoryError: Java heap sapce</code></p><p>JVM 参数常用的有两个，用于设置内存占用大小<br>-Xms：堆的初始大小<br>-Xmx：堆的最大占用</p><p>为什么一般都会将这两个参数设置成一样？<br>因为当堆内存不足需要进行扩容的时候，会发生内存抖动，对程序运行的稳定性会有一定的影响</p><h2 id="线上诊断方法-1"><a href="#线上诊断方法-1" class="headerlink" title="线上诊断方法"></a>线上诊断方法</h2><p>包括但不限于：</p><ul><li>jps：查看系统中存在的 Java 进程</li><li>jmap：查看堆内存占用情况，jmap -head pid</li><li>jconsole：图形界面的，多功能监测工具，可以连续监测（可测出是否发生死锁）</li><li>jvisualvm：堆 dump</li></ul><hr><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>线程共享，存放一些类的基本信息（类，类加载器，运行时常量池），逻辑上是堆的一部分，不同厂商有不同的实现</p><p>HotSpot 在 1.7 之前用永久代（堆），1.8 后用元空间（操作系统内存）</p><p>方法区是规范，永久代或者元空间是其中一种实现，方法区会发生内存溢出<br>1.8 以前会导致永久代内存溢出：<code>-XX:MaxPermSize=m（OutOfMemory：PermGen space）</code><br>1.8 之后会导致元空间内存溢出：<code>-XX:MaxMetaspaceSize=m（OutOfMemory：Metaspace）</code></p><hr><h1 id="字符串常量池，串池（StringTable）"><a href="#字符串常量池，串池（StringTable）" class="headerlink" title="字符串常量池，串池（StringTable）"></a>字符串常量池，串池（StringTable）</h1><p>常量池：是一张表，维护类名，方法名，参数类型，字面量等信息</p><p>运行时常量池：当类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><p>字符串常量池：字符串是日常开发中使用得非常多的类，池化技术某种程度上会有性能上的提升</p><p>如何判断字符串是在堆还是在串池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -v x.class 查看二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</p><p>不同的 JDK 版本可以看到反编译出来的不一样</p><p>JDK 1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Classfile /home/linweiyuan/Temp/test/Test.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Sep <span class="number">24</span>, <span class="number">2022</span>; size <span class="number">759</span> bytes</span><br><span class="line">  MD5 checksum 1eeb9a3b24c5c4f6a213e62ca4ee1691</span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">19</span>            <span class="comment">// a</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">20</span>            <span class="comment">// b</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">4.</span>#<span class="number">22</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">4.</span>#<span class="number">23</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">24</span>            <span class="comment">// Test</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">11</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">12</span> = Utf8               Code</span><br><span class="line">  #<span class="number">13</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               a</span><br><span class="line">  #<span class="number">20</span> = Utf8               b</span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">26</span>:#<span class="number">27</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">28</span>:#<span class="number">29</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">24</span> = Utf8               Test</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">26</span> = Utf8               append</span><br><span class="line">  #<span class="number">27</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">28</span> = Utf8               toString</span><br><span class="line">  #<span class="number">29</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">17</span>: aload_2</span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">24</span>: astore_3</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br></pre></td></tr></table></figure><p>JDK 9+，我这里用的是 JDK 17，但其实从 9 开始就变了，之前有试过，最近整理笔记，电脑上 JDK 9 已经没有了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Classfile /home/linweiyuan/Temp/test/Test.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Sep <span class="number">24</span>, <span class="number">2022</span>; size <span class="number">759</span> bytes</span><br><span class="line">  SHA-<span class="number">256</span> checksum 1f929ea79bba2fa30f55910a61ea7627d430b3dff13f7bdb8cd275e901a0343d</span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">61</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">15</span>                         <span class="comment">// Test</span></span><br><span class="line">  super_class: #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">2</span>, attributes: <span class="number">3</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = String             #<span class="number">8</span>             <span class="comment">// a</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               a</span><br><span class="line">   #<span class="number">9</span> = String             #<span class="number">10</span>            <span class="comment">// b</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               b</span><br><span class="line">  #<span class="number">11</span> = InvokeDynamic      #<span class="number">0</span>:#<span class="number">12</span>         <span class="comment">// #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">12</span> = NameAndType        #<span class="number">13</span>:#<span class="number">14</span>        <span class="comment">// makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               makeConcatWithConstants</span><br><span class="line">  #<span class="number">14</span> = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">16</span>            <span class="comment">// Test</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               Test</span><br><span class="line">  #<span class="number">17</span> = Utf8               Code</span><br><span class="line">  #<span class="number">18</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               main</span><br><span class="line">  #<span class="number">20</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">23</span> = Utf8               BootstrapMethods</span><br><span class="line">  #<span class="number">24</span> = MethodHandle       <span class="number">6</span>:#<span class="number">25</span>          <span class="comment">// REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">25</span> = Methodref          #<span class="number">26.</span>#<span class="number">27</span>        <span class="comment">// java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">26</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/invoke/StringConcatFactory</span></span><br><span class="line">  #<span class="number">27</span> = NameAndType        #<span class="number">13</span>:#<span class="number">29</span>        <span class="comment">// makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/invoke/StringConcatFactory</span><br><span class="line">  #<span class="number">29</span> = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #<span class="number">30</span> = String             #<span class="number">31</span>            <span class="comment">// \u0001\u0001</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               \u0001\u0001</span><br><span class="line">  #<span class="number">32</span> = Utf8               InnerClasses</span><br><span class="line">  #<span class="number">33</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #<span class="number">35</span> = Class              #<span class="number">36</span>            <span class="comment">// java/lang/invoke/MethodHandles</span></span><br><span class="line">  #<span class="number">36</span> = Utf8               java/lang/invoke/MethodHandles</span><br><span class="line">  #<span class="number">37</span> = Utf8               Lookup</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: aload_1</span><br><span class="line">         <span class="number">7</span>: aload_2</span><br><span class="line">         <span class="number">8</span>: invokedynamic #<span class="number">11</span>,  <span class="number">0</span>             <span class="comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">        <span class="number">13</span>: astore_3</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">24</span> REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #<span class="number">30</span> \u0001\u0001</span><br><span class="line">InnerClasses:</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> #<span class="number">37</span>= #<span class="number">33</span> of #<span class="number">35</span>;    <span class="comment">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br></pre></td></tr></table></figure><p>得出结论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.9 -&gt; StringConcatFactory.makeConcatWithConstants()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// StringConcatFactory.makeConcatWithConstants()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 编译期优化</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false，因为 s3 存在串池中，s4 是 new 出来的对象在堆中</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true，因为 ab 已经存在串池中了（s3），对于确定的字符串（不是变量），Java 会进行编译期优化</span></span><br></pre></td></tr></table></figure><h2 id="StringTable-特性"><a href="#StringTable-特性" class="headerlink" title="StringTable 特性"></a>StringTable 特性</h2><ul><li>常量池中的字符串只是符号，第一次用到时才变为对象</li><li>利用串池的机制，可以避免重复创建字符串对象</li><li>字符串常量拼接的原理是编译期优化</li><li>用 intern() 可以主动把串池中还没有的字符串对象放入串池（尝试放入串池，有则不会放入，没有则放入，无论放入是否成功，返回的都是串池中的对象）</li></ul><p>这里有一个要注意的地方，JDK 1.8 intern() 将自己放入串池（一个对象），JDK 1.6 把自己复制一份放进串池（两个对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入了串池，并且返回了串池中的对象 ab</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true, 因为串池中还没有，intern() 放入了后，s 此时在串池中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 串池中已经有了 ab</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, 因为串池放入失败，s还在堆中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时 s 在堆中</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, ab 此时在串池中，s 在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等</span></span><br><span class="line">System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false, 因为串池放入失败，s 还在堆中</span></span><br></pre></td></tr></table></figure><h2 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h2><ul><li>1.6：常量池的一部分，位于永久代中（永久代 Full GC 才会触发，字符串用的场景很多，但是好多都是可以回收的，内存占用太多会造成永久代内存不足）（PermGen space）</li><li>1.8：堆中的一部分（堆 Minor GC 就会触发）（Heap space）</li><li>-XX:-UseFCOverheadLimit（+启用，-禁用，默认启用）：如果 98%的时间花在了垃圾回收上，但是只有 2% 的堆内存回收了，此时 JVM 直接抛出 <code>OutOfMemoryError：GC overhead limit exceeded</code></li></ul><h2 id="StringTable-性能调优"><a href="#StringTable-性能调优" class="headerlink" title="StringTable 性能调优"></a>StringTable 性能调优</h2><p>StringTable 本质上是一个哈希表，哈希表性能与桶的个数有关</p><ul><li>桶个数太大，元素分散，哈希碰撞机率减少，检索速度较快</li><li>桶个数太小，哈希碰撞机率增加，链表就会变长，查找速度就会降低</li></ul><p>可以通过 JVM 参数调整桶的个数，-XX:StringTableSize&#x3D;12345（最小值 1009）</p><hr><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>最快的 GC 是不发生 GC</p><h2 id="如何判断对象是否能回收"><a href="#如何判断对象是否能回收" class="headerlink" title="如何判断对象是否能回收"></a>如何判断对象是否能回收</h2><ul><li>引用计数法（有循环引用问题，A 引用 B，B 引用 A，都不会被回收，JVM 不是这种）</li><li>可达性分析算法（JVM 采用这种，GC Roots）<ul><li>哪种可作为 Roots？(可以用 Eclipse Memory Analyzer 查看，jps -&gt; jmap -dump:format&#x3D;b,live,file&#x3D;m.bin pid)<ul><li>System Class（核心的类，Object, HashMap, String 等）</li><li>Native Stack（操作系统方法执行时引用的 Java 对象）</li><li>Thread（活动线程）</li><li>Busy Monitor（被加锁的对象，回收了，就无法解锁）</li></ul></li></ul></li><li>四种引用<ul><li>强引用（new，赋值，沿着 GC Roots 能找到，就不会被回收）</li><li>软引用（没有强引用时，发生垃圾回收，如果内存不足，再执行一次，被回收，可配合引用队列使用释放自身）<ul><li>SoftReference</li><li>ReferenceQueue, new SoftReference(obj, queue)</li><li>当 obj 被回收时，进入队列</li><li>queue.poll() 获取自身，遍历 remove()</li></ul></li><li>弱引用（没有强引用时，只要发生了垃圾回收，被回收，可配合引用队列使用释放自身）<ul><li>WeakReference</li></ul></li><li>虚引用（必须配合引用队列使用，用于 NIO 中，由 Reference Handler 处理）<ul><li>PhantomReference</li></ul></li><li>终结器引用（必须配合引用队列使用，finalize() 后进入队列，由 Finalizer 处理）</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li>标记清除：速度较快，容易产生内存碎片（空间不连续，数组放不下）</li><li>标记整理：速度较慢，没有内存碎片，标记 -&gt; 清除 -&gt; 整理（会移动对象，因此对象的引用地址会变，需要做额外的工作来更新）</li><li>复制：没有内存碎片，需要占用双倍内存空间，将内存分成大小相等的两块（from, to）发生垃圾回收时，交换位置</li></ul><h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>新生代（朝生夕死）：</p><ul><li>eden</li><li>from</li><li>to</li></ul><p>垃圾回收过程（GC 都会 Stop The World，时间上新生代短一点，老年代长一点，暂停其他用户线程，让垃圾回收线程先执行完）</p><ul><li>新对象默认存放在 eden</li><li>当空间不足时，触发 Minor GC</li><li>标记-清除-复制，把存活的复制到 to（注意不是到 from），寿命加 1</li><li>交换 from to 位置（谁是空的谁就是 to）</li><li>继续放对象</li><li>…</li><li>eden 存活的复制到 to，寿命加 1</li><li>原来在 from 的移到存活后移到 to,寿命加 1</li><li>交换 from to 位置</li><li>…</li><li>寿命超过阈值（15，保存在对象头，4bit，最高 1111 -&gt; 15），晋升到老年代</li><li>如果老年代也放不下，先尝试 Minor GC, 内存还不够，触发 Full GC，再不够，抛出 OOM</li><li>大对象在新生代空间不够，但老年代空间够的情况下，直接晋升</li></ul><p>相关 JVM 参数</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td></tr><tr><td>-Xmx &#x2F; -XX:MaxHeapSize&#x3D;size</td><td>堆最大大小</td></tr><tr><td>-Xmn &#x2F; -XX:NewSize&#x3D;size, -XX:MaxNewSize&#x3D;size</td><td>新生代大小</td></tr><tr><td>-XX:InitialSurvivorRatio&#x3D;ratio, -XX:+UseAdaptiveSizePolicy</td><td>幸存区比例（动态）</td></tr><tr><td>-XX:SurvivorRatio&#x3D;ratio</td><td>幸存区比例</td></tr><tr><td>-XX:MaxTenuringThreshold&#x3D;threshold</td><td>晋升阈值</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>晋升详情</td></tr><tr><td>-XX:+PrintGCDetails -verbose:gc</td><td>GC 详情</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC 前 Minor GC</td></tr></tbody></table><p>线程内的 OOM 不会导致整个 JVM 挂掉</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><ul><li>串行<ul><li>单线程</li><li>适合堆内存较小，个人电脑，CPU 个数少（因为是单线程）</li><li>-XX:+UseSerialGC&#x3D;Serial+SerialOld</li></ul></li><li>吞吐量优先（1.8 默认）<ul><li>多线程</li><li>适合堆内存较大，多核 CPU</li><li>让单位时间内，STW 的时间最短</li><li>-XX:+UseParallelGC</li><li>-XX:+UseParallelOldGC</li><li>-XX:+UseAdaptiveSizePolicy</li><li>-XX:GCTimeRatio&#x3D;99 (1 &#x2F; 1 + ratio, 默认 99，0.01，100 分钟内只能一分钟用于垃圾回收，因为上一行配置了动态调整，所以一般会自动增加堆的大小，大小增加了，就能放更多的东西，垃圾回收的次数就会降低，吞吐量就会提高，一般设置 19)</li><li>-XX:MaxGCPauseMillis&#x3D;200（毫秒，和上面的配置冲突，只能取折中，因为堆增大了，虽然 GC 次数减少，但单次的时间会增加）</li><li>-XX:ParallelGCThreads&#x3D;n</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>适合堆内存较大，多核 CPU</li><li>尽可能让单次 STW 的时间最短</li><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+UseParNewGC SerialOld</li><li>-XX:ParallelGCThreads&#x3D;n</li><li>-XX:ConcGCThreads&#x3D;n</li><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</li><li>-XX:+CMSScavengeBeforeRemark</li></ul></li></ul><p>如何区分吞吐量优先和响应时间优先？</p><p>吞吐量优先：比如，每次花费 0.2 秒，一小时两次，共 0.4 秒，垃圾回收时间占比越低，吞吐量越高</p><p>响应时间优先：比如，每次只需 0.1 秒，但可能一小时发生了 5 次，共 0.5 秒</p><ul><li>G1（Garbage First，JDK 9 默认，废弃 CMS）<ul><li>同时注重吞吐量和低延迟，默认的暂停目标是 200ms</li><li>超大堆内存，将堆划分成多个大小相等的 Region</li><li>整体上是标记-整理，两个区域之间是复制</li><li>-XX:+UseG1GZ</li><li>-XX:G1HeapRegionSize&#x3D;size</li><li>-XX:MaxGCPauseMillis&#x3D;ms</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序计数器（Program-Counter-Register）&quot;&gt;&lt;a href=&quot;#程序计数器（Program-Counter-Register）&quot; class=&quot;headerlink&quot; title=&quot;程序计数器（Program Counter Register</summary>
      
    
    
    
    <category term="JVM" scheme="https://linweiyuan.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://linweiyuan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/07/04/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/07/04/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-07-04T13:25:16.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><ul><li>aop</li><li>beans</li><li>context</li><li>core</li><li>jdbc</li><li>test</li><li>web</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>分为四个阶段</p><ul><li>实例化</li><li>属性赋值</li><li>初始化</li><li>销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">doCreateBean() &#123;</span><br><span class="line">  <span class="comment">// InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span></span><br><span class="line">  createBeanInstance() <span class="comment">// 实例化</span></span><br><span class="line">  <span class="comment">// InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span></span><br><span class="line">  populateBean() <span class="comment">// 属性赋值</span></span><br><span class="line">  <span class="comment">// BeanPostProcessor.postProcessBeforeInitialization</span></span><br><span class="line">  initializeBean() <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// BeanPostProcessor.postProcessAfterInitialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aware 都是在初始化阶段之前调用的</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>单例：Bean 默认为单例模式</li><li>工厂：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例</li><li>代理：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 的字节码生成技术</li><li>模板方法：用来解决代码重复的问题，比如 RestTemplate，JpaTemplate</li><li>观察者：当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被强制更新，比如 ApplicationListener</li></ul><h1 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h1><p>指的是当多个事务同时存在的时候，Spring 如何处理这些事务的行为</p><p>propagation：</p><ul><li>required：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，最常用</li><li>requires_new：无论当前存不存在事务，都创建新事务</li><li>supports：如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li>not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li>never：以非事务方式执行，如果当前存在事务，则抛出异常</li><li>nested：如果当前存在事务，则在嵌套事务中执行，如果当前没有事务，则按 required 属性执行</li><li>mandatory：如果当前存在事务，就加入，不存在则抛出异常</li></ul><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul><li>isolation_default</li><li>isolation_read_uncommitted</li><li>isolation_read_committed</li><li>isolation_repeatable_read</li><li>isolation_serializable</li></ul><h1 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h1><ul><li>singleton：bean 在每个 Spring IoC 容器中只有一个实例</li><li>prototype：一个 bean 的定义可以有多个实例</li><li>request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效</li><li>session：在一个 http session 中，一个 bean 定义对应一个实例，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效</li><li>global-session：在一个全局的 http session 中，一个 bean 定义对应一个实例，该作用域仅在基 web 的 Spring ApplicationContext 情形下有效</li></ul><p>默认是 singleton，使用 prototype 作用域需要慎重的考虑，因为频繁创建和销毁 bean 会带来很大的性能开销</p><h1 id="单例-bean-是线程安全的吗"><a href="#单例-bean-是线程安全的吗" class="headerlink" title="单例 bean 是线程安全的吗"></a>单例 bean 是线程安全的吗</h1><p>不是，Spring 框架中的单例 bean 不是线程安全的</p><p>Spring 中的 bean 默认是单例模式，Spring 框架并没有对单例 bean 进行多线程的封装处理</p><p>实际上大部分时候 Spring bean 是无状态的（比如 dao），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view mode 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 singleton 改成 prototype 这样请求 bean 相当于 new bean，就可以保证线程安全</p><ul><li>有状态就是有数据存储功能</li><li>无状态就是不会保存数据</li></ul><p>那 Spring 如何处理线程并发问题的？</p><p>在一般情况下，只有无状态的 bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 bean 都可以声明为 singleton 作用域，因为 Spring 对一些 bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题</p><p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题，同步机制采用了时间换空间的方法，仅提供一份变量，不同的线程在访问前需要先获得锁，没获得锁的线程则需要排队</p><p>而 ThreadLocal 采用了空间换时间的方式，ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突，因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了，ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal</p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><ul><li>@Component：将 Java 类标记为 bean，是任何 Spring 管理组件的通用型，Spring 的组件扫描机制扫描并用 IoC 容器进行管理</li><li>@Controller：将类标记为 Spring Web MVC 控制器，会自动导入到 IoC 容器中</li><li>@Service：基本和 @Component 一样，只是用在 service 层的话，会更好地见名知意</li><li>@Repository：除了具有 @Component 的作用外，还具有额外的作用，可以将未经检查的异常转换为 Spring DataAccessException</li></ul><h1 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h1><ul><li>官方标准<ul><li>@Resource：JSR250，按名称或类型注入，不支持 @Primary</li><li>@Inject：JSR330，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合@Primary 可选择优先注入</li><li>@Autowired：Spring 自己的实现，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合 @Primary 可选择优先注入</li></ul></li></ul><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>除了 MySQL 四种事务隔离级别外，多了个默认，就是数据库是什么就是什么</p><ul><li>isolation_default</li><li>isolation_read_uncommitted</li><li>isolation_read_committed</li><li>isolation_repeatable_read</li><li>isolation_serializable</li></ul><h1 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h1><p>IoC 就是控制反转，它把传统的有程序代码直接 new 的对象的调用权交给 Spring 容器，通过容器来实现对象组件的装配和管理，所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器</p><p>Spring IoC 负责创建对象，管理对象，装配对象，配置对象，并且管理这些对象的整个生命周期</p><p>IoC 有什么作用？</p><ul><li>管理对象的创建和依赖关系的维护，对象的创建并不是一件简单的事，在对象管理比较复杂时，如果依赖关系需要程序代码来维护，比较痛苦</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>A 有 B，B 有 A<br>Bean 的创建过程：</p><ul><li>获取 bean 定义</li><li>通过反射创建原始对象</li><li>填充属性（这一步就是依赖注入）</li><li>完成对象的创建放到一级缓存</li></ul><p>A 创建的时候，通过 bean 的定义创建了一个原始对象，然后将 lambda 表达式放到三级缓存中，接着进行属性的填充，填充的时候发现 B 还没有，于是按照同样的方式来创建 B，等到 B 进行属性注入的时候，分别从一级，二级，三级缓存里面找 A，最后在三级缓存里面找到，于是将 A 放到二级缓存中，并从三级缓存中删除 A，此时的 A 是一个对象并未完成初始化好的对象，但是已经创建出来了，那么 B 属性注入成功，就放到一级缓存中，接着回到 A 的属性注入，注入完成 B 后，A 也完成了创建，就放到一级缓存中，并从二级缓存中删掉 A</p><p>为什么需要三级缓存来解决循环依赖？</p><p>如果是普通的对象，用一级缓存就可以，但是 Spring 的对象很多都是动态代理增强的，三级缓存里存的是一个 lambda 表达式，根据对象是否有动态代理的需求，进行包装返回，这时的对象是未完成初始化的，如果不放到二级缓存直接放到一级缓存，一级缓存里会出现既有初始化完成的 bean，又有未初始化完成的，管理起来就可能会出现不可预知的错误，也不符合单一职责原则。在缓存 bean 的过程中，三个级别的缓存都是互斥的，最终都会只保留一份完成初始化的 bean，放到一级缓存里</p><h1 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h1><ul><li>用户发送请求到前端控制器 DispatcherServlet</li><li>DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器请求获取 Handler</li><li>HandlerMapping 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器，返回给 DispatcherServlet</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器</li><li>HandlerAdapter 经过适配调用具体处理器 Handler，也叫后端控制器</li><li>Handler 执行完成，返回 ModelAndView</li><li>HandlerAdapter 将 Handler 执行结构 ModelAndView 返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析</li><li>ViewResolver 解析后返回具体 View</li><li>DispatcherServlet 对 View 进行渲染视图，即将模型数据填充至视图中</li><li>DispatcherServlet 响应用户</li></ul><h1 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h1><p>跨域可以在前端通过 JSONP 来解决，但是 JSNOP 只可以发送 GET 请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此推荐在后端通过 CORS Cross-Origin Resource Sharing 来解决跨域问题，Spring Boot 中可以通过实现 WebMvcConfigurer 接口，然后重写 addCordMappings 方法来解决跨域问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;aop&lt;/li&gt;
&lt;li&gt;beans&lt;/li&gt;
&lt;li&gt;context&lt;/li&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;jdbc&lt;</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Spring Boot" scheme="https://linweiyuan.github.io/tags/Spring-Boot/"/>
    
    <category term="Spring" scheme="https://linweiyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://linweiyuan.github.io/2021/06/28/MySQL%E4%BA%8B%E5%8A%A1.html"/>
    <id>https://linweiyuan.github.io/2021/06/28/MySQL%E4%BA%8B%E5%8A%A1.html</id>
    <published>2021-06-28T15:08:02.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务，首先要了解 ACID</p><h2 id="A-原子性"><a href="#A-原子性" class="headerlink" title="A 原子性"></a>A 原子性</h2><p>原子性体现在回滚上面，如果 SQL 执行出错，要把之前的状态恢复，那怎么知道恢复什么呢，把之前的状态保存在 undo log 里，出错则会执行相反的操作</p><h2 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C 一致性"></a>C 一致性</h2><p>事务执行完毕后，数据库的完整性约束并没有被破坏，主要是通过原子性 + 隔离性 + 持久性来保证</p><h2 id="I-隔离性"><a href="#I-隔离性" class="headerlink" title="I 隔离性"></a>I 隔离性</h2><p>写写操作是通过锁解决，写读操作是基于 MVCC</p><h2 id="D-持久性"><a href="#D-持久性" class="headerlink" title="D 持久性"></a>D 持久性</h2><p>指的是事务一旦提交，对数据库的改变就是永久性的</p><hr><p>MySQL 为了提高效率，会有一个 buffer，每次写到 buffer 中，再定期将 buffer 中的数据刷新到硬盘上，这就会有一个问题，如果 buffer 还没来得及刷盘，MySQL 宕机了，数据就会丢失，因此，引入了 redo log，当数据库的数据进行增删改的时候，先将 本次操作记录到 redo log 中，再写 buffer，这样如果宕机了，还有 redo log 来恢复数据，这样就保证了持久性</p><p>为什么 redo log 写数据要比 buffer 写数据库快？</p><p>因为 buffer 写盘是随机 IO，redo log 是追加的模式，是顺序 IO，效率就高，并且 buffer 持久化数据是以数据页 page 为单位的，默认是 16K，就是说一个数据页上的小小修改都要把整个数据页写入，redo log 只需要写入真正需要的部分，无效的 IO 就大大减少了，效率就提高了</p><p>读未提交：脏读，不可重复读，幻读都有可能出现</p><p>读已提交：避免脏读，可能出现不可重复读和幻读</p><p>重复读：避免脏读和不可重复读，可能出现幻读</p><p>串行化：全部避免，性能差</p><p>脏读: 一个事务修改了数据还没提交，另一个事务读到了旧数据</p><p>不可重复读: 一个事务多次读同一数据，间隔间，另一个事务把数据改了，导致两次读取结果不一样</p><p>幻读: 一个事务对全表数据进行修改，另一个事务往表中新增数据，修改完成后莫名其妙出现了没有修改到的数据</p><p>MySQL 的 InnoDB 默认是 RR，为什么可以解决幻读？</p><p>因为默认开启了间隙锁，这样就防止了两次 select 之间，有另外的事务进行增删操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h1&gt;&lt;p&gt;事务，首先要了解 ACID&lt;/p&gt;
&lt;h2 id=&quot;A-原子性&quot;&gt;&lt;a href=&quot;#A-原子性&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁</title>
    <link href="https://linweiyuan.github.io/2021/06/25/MySQL%E9%94%81.html"/>
    <id>https://linweiyuan.github.io/2021/06/25/MySQL%E9%94%81.html</id>
    <published>2021-06-25T15:03:53.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>update 的时候行级锁，如果未 commit，另一个事务会尝试拿锁，超时则报错</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p>索引失效，行锁会升级为表锁，比如 update 的时候有 or，这样就算在一个事务中 update id &#x3D; 1 or id &#x3D; 2，另一个事务要 update id &#x3D; 3，也会阻塞，一旦发生表锁，并发度是比较低的，所以要避免索引失效</p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>一般发生在范围查询里面，把整个范围加锁，如果要在这个范围内插入新数据，也会阻塞，性能影响也是比较大的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到一些锁相关数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;行锁&quot;&gt;&lt;a href=&quot;#行锁&quot; class=&quot;headerlink&quot; title=&quot;行锁&quot;&gt;&lt;/a&gt;行锁&lt;/h1&gt;&lt;p&gt;update 的时候行级锁，如果未 commit，另一个事务会尝试拿锁，超时则报错&lt;/p&gt;
&lt;h1 id=&quot;表锁&quot;&gt;&lt;a href=&quot;#表锁</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引相关</title>
    <link href="https://linweiyuan.github.io/2021/06/18/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3.html"/>
    <id>https://linweiyuan.github.io/2021/06/18/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3.html</id>
    <published>2021-06-18T14:04:59.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><p>要了解索引，首先要了解 MySQL 的 B+树数据结构</p><p>为什么是 B+ 树？</p><p>和 B 树相比，多了箭头，称为叶子节点，其实就是一个单向链表，进行了排序，解决了回旋查找的问题</p><p>非叶子节点只存 key，叶子节点既存 key 又存 value（数据地址）</p><hr><h1 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h1><p>聚簇索引就是把数据和索引放在一个文件里面，叶子节点保存行数据，数据按照索引的顺序来进行存储，也就是说索引项的顺序和表中记录的物理顺序一致，InnoDB 中，在聚簇索引之上创建的索引称为辅助索引，比如复合索引，前缀索引，唯一索引等</p><ul><li>聚簇索引是一个概念，默认实现是是主键</li><li>如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替</li><li>如果没有唯一非空的索引，InnoDB 会在内部生成一个名为 GEN_CLUST_INDEX 的隐式的聚簇索引</li></ul><p>在数据（索引）文件中，非叶子节点保存的是主键，叶子节点保存的是真实数据，因为只有一个文件</p><p>辅助索引中，非叶子节点保存的是字段的值（排序），叶子节点保存的是该条记录的主键 ID 值</p><p>所以，如果是主键索引，只需查一次，一定程度上会比 MyISAM 快，但是辅助索引要查到 ID 再到主键索引查数据，要查两次，一定程度上会比 MyISAN 慢</p><p>为什么不能 select *，要尽可能使用覆盖索引？</p><p>如果是查单个字段，在这个字段上建立了索引，只需查一次就能拿到该字段数据，如果 select *，那就要查到 ID，再根据 ID 来查询全部，查两次</p><h1 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h1><p>将数据和索引分开存储，表数据存储顺序和索引顺序无关</p><p>在索引文件中，非叶子节点保存的是主键，叶子节点保存的是主键和数据在数据文件中的地址</p><hr><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><ul><li>尽量在只需要查询到的字段上加索引（where）</li><li>基数小的字段不加索引（出现重复的越多越不加， 唯一才能查询快）</li><li>如果字符串太长但是前面不重复， 使用短索引（根据前面几个字符就能确定唯一）</li><li>不要过度使用索引， 占用磁盘空间， 更新操作影响性能</li><li>建立索引的字段， 尽量不要有 null（not null + 默认值）</li><li>like 查询中前导模糊查询不能命中索引（like ‘%a%’ 不走索引，like ‘a%’ 走）</li><li>如果字段是字符串， 查询时用整形， 索引失效</li><li>复合索引（最左原则， 查询条件如果不包含第一个字段， 索引失效）</li><li>sql 查询 cpu 开销：or &gt; in &gt; union</li><li>or 查询如果前面的条件有索引， 后面没有， 索引失效</li><li>否定查询索引失效（!&#x3D;， &lt;&gt;， not in， not exists， not like）</li><li>用 explain 来分析 sql 性能</li></ul><hr><h1 id="索引失效原理"><a href="#索引失效原理" class="headerlink" title="索引失效原理"></a>索引失效原理</h1><p>针对联合索引的情况，数据保存的时候，是有顺序的，两个字段 a 和 b，先按 a 排序，在 a 相同的情况下按 b 排序，所以如果直接查 b，是无序的，因此不走索引，要全表扫描，范围查找，模糊查询也是这个道理</p><hr><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ul><li>最左前缀法则：如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右（和 B+ 树的数据结构有关），比如 abc，在这种情况下：<ul><li>abc：有效</li><li>ac：a 有效 c 无效</li><li>bc：bc 都无效</li><li>c：无效</li></ul></li><li>不要对索引进行如下处理：<ul><li>计算：如加减乘除，不等，is null， is not null， or</li><li>函数：如 sum()， round()等</li><li>类型转换：如 id &#x3D; ‘1’，本来是数字写成了字符串</li></ul></li><li>索引不要放在范围查找的右边</li><li>减少 select * 的使用</li><li>like 模糊查询：只留右边的百分号，那是否两个百分号没得优化呢，也不是，可以使用覆盖索引，所谓覆盖索引就是 select 查询的字段和 where 里的字段是一致的，也会走索引</li><li>order by 优化，避免出现 Using filesort 文件内排序，所谓 filesort，就是说它没有按照索引本身来进行排序，而是在外面开辟了一块内存，把数据复制进去进行排序，这样内存就会被多占用一份空间，而内存是比较宝贵的资源，比较影响性能</li></ul><p>其实也可以考虑不在 MySQL 里排序，而在代码里进行排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B+ 树&quot;&gt;&lt;/a&gt;B+ 树&lt;/h1&gt;&lt;p&gt;要了解索引，首先要了解 MySQL 的 B+树数据结构&lt;/p&gt;
&lt;p&gt;为什么是 B+ 树？&lt;/p&gt;
&lt;p&gt;和 B 树相比，多了箭</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="https://linweiyuan.github.io/2021/05/20/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"/>
    <id>https://linweiyuan.github.io/2021/05/20/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html</id>
    <published>2021-05-20T14:03:11.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB 和 MyISAM 的区别</p><ul><li>InnoDB 支持事务，MyISAM 不支持，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一</li><li>InnoDB 支持外键，MyISAM 不支持，对一个包含外键的 InnoDB 表转为 MyISAM 会失败</li><li>InnoDB 是聚集索引（聚簇索引），MyISAM 是非聚集索引</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，这也是默认存储引擎改变的重要原因之一</li><li>MyISAM 在硬盘上存储为三个文件<ul><li>.frm：表的定义</li><li>.myd：数据文件</li><li>.myi：索引文件</li></ul></li><li>InnoDB 是两个文件（没有专门保存数据的文件）<ul><li>.frm：表的定义</li><li>.ibd：数据和索引文件，数据以主键进行聚集存储，把真正的数据保存在叶子节点中</li></ul></li><li>全文索引都支持</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB 和 MyISAM 的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB 支持事务，MyISAM 不支持，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一&lt;/li&gt;
&lt;li&gt;InnoDB 支持外键，MyISAM 不支持，对一个包含外</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MVCC</title>
    <link href="https://linweiyuan.github.io/2021/05/15/MVCC.html"/>
    <id>https://linweiyuan.github.io/2021/05/15/MVCC.html</id>
    <published>2021-05-15T13:57:08.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>Multi Version Concurrency Control 多版本并发控制</p><p>什么是 MySQL InnoDB 下的当前读和快照读？</p><ul><li>快照读：一般的 select 都是快照读（事务级别不是串行化），基于 MVCC 实现，既然如此，读到的数据就不一定是当前最新的数据，有可能是之前历史版本的数据</li><li>当前读：读取的数据是当前最新的版本，会对数据进行加锁，防止其他事务修改，属于悲观锁<ul><li>selet in share mode（共享锁）</li><li>select for udate（排他锁）</li><li>update， insert， delete（排他锁）</li><li>串行化事务隔离级别</li></ul></li></ul><p>MVCC 是怎么实现的？</p><p>表中一行数据包含数据本身，事务 ID（自增）和回滚指针</p><ul><li>undo log</li><li>版本链</li><li>readview<ul><li>creator_id：表示生成该 readview 的事务的事务 id</li><li>m_ids： 表示在生成 readview 时当前系统中活跃的读写事务的事务 id 列表，活跃指的就是还没 commit</li><li>min_trx_id：表示在生成 readview 时当前系统中活跃的读写事务中的最小事务 id，也就是 m_ids 最小值，第 0 个元素</li><li>max_trx_id：表示生成 readview 时系统中应该分配给下一个事务的 id（和 min 不同，max 不是 m_ids 最后一个，而是下一个）</li></ul></li></ul><p>trx_id 是数据库中数据的 trx_id</p><p>trx_id &#x3D;&#x3D; creator_trx_id：可以正常访问，场景可能是 update 了后，马上开始 select</p><p>trx_id &lt; min_trx_id：可以访问，表示 trx_id 已经是提交的了</p><p>trx_id &gt; max_trx_id：不可以访问，已经超出版本链了</p><p>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id：如果 trx_id 在 m_ids 里，不可以访问，不在则可以</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC&quot;&gt;&lt;a href=&quot;#MVCC&quot; class=&quot;headerlink&quot; title=&quot;MVCC&quot;&gt;&lt;/a&gt;MVCC&lt;/h1&gt;&lt;p&gt;Multi Version Concurrency Control 多版本并发控制&lt;/p&gt;
&lt;p&gt;什么是 MySQL Inn</summary>
      
    
    
    
    <category term="数据库" scheme="https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linweiyuan.github.io/tags/MySQL/"/>
    
    <category term="MVCC" scheme="https://linweiyuan.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>List, Set, Map相关知识点</title>
    <link href="https://linweiyuan.github.io/2021/04/30/List-Set-Map%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://linweiyuan.github.io/2021/04/30/List-Set-Map%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-04-30T13:47:24.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>HashMap 是非线程安全的，HashTable 是线程安全的，HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰，HashMap 有线程安全版本的实现 <code>ConcurrentHashMap</code></p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>因为线程安全的问题，HashMap 要比 HashTable 效率高一些，HashTable 基本已经被淘汰了</p><h2 id="null-的支持"><a href="#null-的支持" class="headerlink" title="null 的支持"></a>null 的支持</h2><p>HashMap 中可以将 null 设为 key（hashCode 为 0）,但是只允许有一个，value 为 null 可以有多个</p><p>HashTable 中 key 或 value 任何一个 null 都会有 NullPointerException（value 如果判断是 null 直接抛出 NPE，key 没有判断，但是 key 如果为 null,key.hashCode()就会报 NPE）(ConcurrentHashMap 无论 key 还是 value 为 null，都会主动抛 NPE)</p><h2 id="初始容量和扩容"><a href="#初始容量和扩容" class="headerlink" title="初始容量和扩容"></a>初始容量和扩容</h2><p>创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，每次扩容，容量变为原来的 2n + 1；HashMap 的默认初始化大小为 16,每次扩容，容量变为原来的两倍</p><p>如果指定了初始值，HashTable 会直接用这个值，HashMap 会用 tableSizeFor()方法将其扩充为 2 的幂次方</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>JDK 1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）并且数组长度大于 64,会将链表转为红黑树，以减少搜索时间，当红黑树节点低于 6 时，转回链表</p><p>HashTable 没有这样的机制</p><hr><h1 id="HashMap-和-HashSet-的区别"><a href="#HashMap-和-HashSet-的区别" class="headerlink" title="HashMap 和 HashSet 的区别"></a>HashMap 和 HashSet 的区别</h1><p>HashSet 底层就是基于 HashMap 来实现的，HashSet 执行 add(xxx)的时候，把 xxx 作为 key 放到 map 里，key 对应的 value 是一个无意义 new Object()，因为 map 中的 key 是唯一的，所以 set 存的元素不能重复</p><hr><h1 id="HashMap-JDK1-7-和-JDK1-8-的区别"><a href="#HashMap-JDK1-7-和-JDK1-8-的区别" class="headerlink" title="HashMap JDK1.7 和 JDK1.8 的区别"></a>HashMap JDK1.7 和 JDK1.8 的区别</h1><ul><li>JDK 1.7 之前是数组加链表，JDK 1.8 后也属数组加链表，如果哈希冲突严重则转换为红黑树</li><li>JDK 1.7 头插法（先将原位置的数据移到后一位，再插入数据到该位置），JDK 1.8 尾插法（直接插入到链表尾部&#x2F;红黑树），尾插法能解决并发下的死循环问题</li></ul><hr><h1 id="HashMap-加载因子"><a href="#HashMap-加载因子" class="headerlink" title="HashMap 加载因子"></a>HashMap 加载因子</h1><p>为什么不能是 0.5 或者 1.0，而是 0.75</p><p>如果是 1.0，只有当 HashMap 满了才会扩容，哈希计算出来的结果很难说刚好落在每一个空的位置上，所以发生扩容的时候，很大程度上 HashMap 已经发生了多次哈希冲突了，如果 HashMap 变成了链表或者红黑树，则对元素操作的时间就会增加，运行效率就会降低，影响性能，属于时间换空间</p><p>如果是 0.5，当 HashMap 放了一半元素时则扩容，但是每次当一半的时候就扩容，则至少有一半的空间是永远用不到，造成了内存的浪费，相对地，哈希冲突概率减少，元素操作时间也会减少，属于空间换时间</p><p>HashMap 源码的注释，0.75 是一个平衡点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">As a general rule, the <span class="keyword">default</span> load <span class="title function_">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup <span class="title function_">cost</span> <span class="params">(reflected in most of the operations of the HashMap class, including get and put)</span>. The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</span><br></pre></td></tr></table></figure><hr><h1 id="HashMap-扩容流程"><a href="#HashMap-扩容流程" class="headerlink" title="HashMap 扩容流程"></a>HashMap 扩容流程</h1><p>流程：</p><ul><li>判断当前容量大小是否为空，如果为空（未设置容量初始值），则把容量扩充为 16</li><li>获取 key 的 hashCode，对 hashCode 进行扰动处理，计算出元素的下标</li><li>根据下标判断有无 hash 碰撞，如果没有，则直接放入桶中</li><li>如果发生碰撞，比较两个 key 是否相等，相等则将新值覆盖旧值，不相等则以链表的形式插入到尾部</li><li>如果插入后链表的长度超过了阈值 8，并且数组长度大于 64，则将链表转换为红黑树</li><li>插入成功后，如果元素个数达到了阈值（初始容量 * 负载因子），则进行扩容操作</li><li>扩容成功后，对元素的下标进行重新计算</li></ul><hr><h1 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>基于动态数组，连续内存存储，随机访问（下标）快，增删满（因为长度固定，扩容需要复制原数组）</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于链表，存储在分散的内存中，增删快，查询慢，需要逐一遍历。遍历时候用迭代器，如果用 fori，每次都要 list.get(i)，重新进行遍历，性能消耗极大（可以用增强性 for 循环 forEach，内部实现也是迭代器）</p><hr><h1 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>两个类都继承了相同的类，实现了相同的接口</li><li>底层都属 Object 数组</li><li>默认的初始化长度都是 10</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul><li>Vector 使用了 synchronized 来实现线程同步，是线程安全的，而 ArrayList 不是线程安全的</li><li>扩容的时候，ArrayList 扩容成原来的 1.5 倍，Vector 扩容成 2 倍</li></ul><hr><h1 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有序，按对象进入的顺序来保存，可重复，允许多个 null 元素，可以使用迭代器遍历，或者下标的方式</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序，不可重复，最多一个 null 元素，只能用迭代器遍历</p><p>为什么 Set 最多只能放一个 null 元素？</p><p>以用得比较多的 HashSet 为例，内部的添加元素方法 add 方法的实现是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 map 就是一个 HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure><p>map 的 value PRESENT 是一个空对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>所以在 HashSet 中添加元素，其实最终是执行了 HashMap 的 put 方法，把这个元素当作一个 key 存进去，value 则是空对象</p><p>HashMap 的 put 方法会对 key 进行一个 hash 计算，算出来 hashCode 确定存放的位置，而当 key 是 null 的时候，hashCode 会是 0，所以如果在 HashSet 中添加了多个 null，全部都是会放到 HashMap 中 hashCode 为 0 的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么 HashSet 的元素不可重复，或者只能放一个 null</p><hr><h1 id="HashSet-存储的元素是否有序"><a href="#HashSet-存储的元素是否有序" class="headerlink" title="HashSet 存储的元素是否有序"></a>HashSet 存储的元素是否有序</h1><p>无序</p><p>HashSet 是 Set 的一个实现类，底层是基于 HashMap 实现的，HashSet 存储的元素对应 HashMap 的 key，因为 HashMap 不能存储重复的 key，所以 HashSet 不能存储重复元素</p><p>由于 HashMap 的 key 是基于 hashCode 的，所以 HashSet 中存储的对象是无序的</p><p>HashSet 没有提供 get 方法，只能通过 Iterator 迭代器获取数据</p><p>有一种情况是 HashSet 中存放的是纯数字，因为子类一般会重写父类的方法，hashCode() 是 Object 的，Integer 在实现的时候，把当前 int 值直接当作 hashCode 返回，所以遍历起来造成一种有序的假象</p><hr><h1 id="集合快速失败机制"><a href="#集合快速失败机制" class="headerlink" title="集合快速失败机制"></a>集合快速失败机制</h1><p>首先要说明为什么 Java 集合遍历，不是集合类实现 Iterator，而是返回它的迭代器对象？</p><p>因为如果是集合本身去实现，那么可能你访问的是别人遍历的数据</p><p>而每次返回新的迭代器，遍历数据时就会互不影响，做到隔离性和独立性<br>（forEach 循环的底层实现就是迭代器）</p><p>集合本身有一个 <code>modCount</code> 属性用来保存集合增删操作的次数，因为迭代器是集合的成员内部类，所以可以随时访问集合的成员属性，所以当获取到集合的迭代器的时候，比如当前 modCount 是 3，next() 的时候判断，获取到的 3 和集合当前的 3 还是一样，则正常执行，否则报错 <code>throw new ConcurrentModificationException()</code></p><p>那有没有办法可以解决这个问题呢？</p><p><code>CopyOnWriteArrayList</code>，增删元素时，创建新数组，复制原数组，写的时候加锁，写在新数组，读的时候不加锁，读在旧数组（适用于读多写少，数据量不大的场景）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap-和-HashTable-的区别&quot;&gt;&lt;a href=&quot;#HashMap-和-HashTable-的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap 和 HashTable 的区别&quot;&gt;&lt;/a&gt;HashMap 和 HashTab</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String, StringBuffer, StringBuilder</title>
    <link href="https://linweiyuan.github.io/2020/12/28/String-StringBuffer-StringBuilder.html"/>
    <id>https://linweiyuan.github.io/2020/12/28/String-StringBuffer-StringBuilder.html</id>
    <published>2020-12-28T13:17:54.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<ul><li>String 是 final 的，每次操作都会产生新的 String</li><li>StringBuffer 和 StringBuilder 都是在原对象基础上操作</li><li>StringBuffer 线程安全（内部采用 synchronized 来实现），StringBuilder 线程不安全</li><li>性能：StringBuilder &gt; StringBuffer &gt; String</li></ul><p>优先使用 StringBuilder，多线程共享变量时使用 StringBuffer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;String 是 final 的，每次操作都会产生新的 String&lt;/li&gt;
&lt;li&gt;StringBuffer 和 StringBuilder 都是在原对象基础上操作&lt;/li&gt;
&lt;li&gt;StringBuffer 线程安全（内部采用 synchronized 来</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hashCode()和equals()</title>
    <link href="https://linweiyuan.github.io/2020/12/25/hashCode-%E5%92%8Cequals.html"/>
    <id>https://linweiyuan.github.io/2020/12/25/hashCode-%E5%92%8Cequals.html</id>
    <published>2020-12-25T12:04:41.000Z</published>
    <updated>2022-09-24T18:39:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>以 HashSet 为例，因为 hash 算法相对来说比较高效，如果两个对象 hashCode 不一样，则这两个对象是不同的对象，省去了遍历 set 逐个对此是否相同</p><p>如果两个对象相等，则 hashCode 一样，调用 equals 对比为 true</p><p>但是反过来如果两个对象的 hashCode 相等，这两个对象则不一定相同（hash 冲突），需要再通过 equals 进一步判断</p><p>如果重写了 equals，也要重写 hashCode，因为有可能出现两个对象内容相等但是地址不相同的情况，存放也会造成重复</p><p>因此:</p><ul><li>hashCode() 用来在最快时间内判断两个对象是否相等，并定位索引位置，但可能出现误差，用来保证效率</li><li>equals() 用来保证可靠</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以 HashSet 为例，因为 hash 算法相对来说比较高效，如果两个对象 hashCode 不一样，则这两个对象是不同的对象，省去了遍历 set 逐个对此是否相同&lt;/p&gt;
&lt;p&gt;如果两个对象相等，则 hashCode 一样，调用 equals 对比为 true&lt;/p&gt;
</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Final修饰符</title>
    <link href="https://linweiyuan.github.io/2020/12/20/Final%E4%BF%AE%E9%A5%B0%E7%AC%A6.html"/>
    <id>https://linweiyuan.github.io/2020/12/20/Final%E4%BF%AE%E9%A5%B0%E7%AC%A6.html</id>
    <published>2020-12-20T13:16:07.000Z</published>
    <updated>2022-09-24T18:39:03.775Z</updated>
    
    <content type="html"><![CDATA[<ul><li>修饰类：不可继承</li><li>修饰方法：不可重写，但可重载</li><li>修饰变量：一旦被赋值则不能再更改（数组不能再赋值，但是里面的值是可变的）</li></ul><p>为什么内部类和匿名内部类只能访问局部 final 变量？<br>当外部类的方法结束时，外部类的局部变量理应销毁了，但是内部类可能还存在（比如线程还在跑），此时内部类访问外部类的变量，就会出现矛盾，这个变量不存在，所以就要把外部类的变量复制一份到内部类，给它使用，但是，不能让这个变量在内部类中被修改后，影响到外部类，可能会出现问题，所以只能是 final</p><p>或者可以用另一种方法，利用原子类的 <code>CAS</code> 特性来设置变量值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;修饰类：不可继承&lt;/li&gt;
&lt;li&gt;修饰方法：不可重写，但可重载&lt;/li&gt;
&lt;li&gt;修饰变量：一旦被赋值则不能再更改（数组不能再赋值，但是里面的值是可变的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么内部类和匿名内部类只能访问局部 final 变量？&lt;br&gt;当外部类的方</summary>
      
    
    
    
    <category term="程序设计" scheme="https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://linweiyuan.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
